{"posts":[{"title":"前端早读精选 - 第二期","text":"总结趋势系列年终总结：2023 最受欢迎的 NodeJS 框架 Framework Description Released Growth Next.js Next.js 是一个用于构建 React 应用程序的框架，提供强大的路由系统、服务器渲染、自动代码分割等功能。它被设计用于构建现代的、可扩展的 Web 应用程序，支持静态生成和服务器渲染。 2016 +53.3/day tRPC tRPC 是一个用于构建类型安全、现代化的后端服务的框架。它允许你使用 TypeScript 定义 API，然后自动生成客户端和服务端代码，以提供类型安全的 API 调用。tRPC 支持多种后端框架，包括 Express、Fastify 等。 2020 +51.5/day Nest Nest 是一个用于构建可扩展且模块化的后端应用程序的框架。它基于 TypeScript，提供了依赖注入、模块化、强大的路由系统等功能。Nest 可以用于构建 RESTful API、WebSocket 应用程序等。 2017 +26.5/day Remix Remix 是一个构建在 React 生态系统之上的现代 JavaScript 框架，专注于构建 Web 应用程序。Remix 的目标是提供一种更好的开发体验和性能优化，通过强调一些现代前端开发最佳实践来简化复杂的应用程序构建。 2020 +24.3/day Strapi Strapi 是一个开源的 Headless CMS，允许开发者创建和管理内容 API。它提供了一个用户友好的界面，支持自定义数据结构和字段，并可通过 API 提供内容。Strapi 可以与各种前端框架和技术一起使用。 2015 +23.7/day SvelteKit SvelteKit 是一个用于构建现代 Web 应用程序的框架，基于 Svelte 框架。它提供了路由、状态管理、服务端渲染等功能，并以编译时生成的方式优化应用程序。SvelteKit 强调简单性和性能 2020 +17.6/day Directus Directus 是一个开源的 Headless CMS，专注于提供可扩展的自定义数据库。它允许开发者通过直接访问数据库表和字段来定义内容结构，同时提供强大的 API，可用于构建各种类型的应用程序。 2012 +17.1/day Redwood Redwood 是一个全栈 JavaScript 框架，旨在简化前端与后端的集成。它使用 React 进行前端开发，GraphQL 作为 API 查询语言，Prisma 用于数据库访问。Redwood 支持自动代码生成、服务端渲染等功能，以提供开发人员高效构建全栈应用的能力。 2019 +12.7/day Nuxt Nuxt.js 是一个基于 Vue.js 的前端框架，用于构建服务端渲染 (SSR)、静态站点生成 (SSG) 和单页应用 (SPA)。Nuxt 提供了一系列的约定和配置选项，简化了 Vue.js 应用程序的开发和部署。 2016 +12.4/day Fastify Fastify是轻量级、高性能的Node.js Web框架，专注于提供快速、低开销的HTTP服务。其采用低开销插件系统、支持异步编程、强调Schema验证，使其成为构建高性能、生产就绪的Web服务的理想选择 2016 +11.3/day Express Express 是一个基于 Node.js 的后端框架，用于构建 Web 应用程序和 API。它是一个轻量级、灵活且易于扩展的框架，通过中间件的概念，可以方便地添加各种功能。Express 提供了路由、HTTP 请求和响应处理等基础功能。 2009 +10.8/day Keystone KeystoneJS 是一个用于构建内容管理系统 (CMS) 和 Web 应用程序的 JavaScript 框架。它基于 Node.js 和 Express，并使用 GraphQL 作为 API 查询语言。Keystone 提供了一个灵活的数据模型、自动生成的管理界面和强大的查询能力，适用于构建各种类型的应用程序。 2018 +4.9/day 上述大部分框架在笔者日常工作中都有接触，其中tRPC 是笔者第一次接触，这里补充一下 tRPC 的信息。之前在 Node 端调用 rpc 接口更多的是选择使用thrift 对 IDL 文件进行编译后使用，而 tRPC 允许您轻松构建和使用完全类型安全的 API，而无需模式或代码生成。采用 Protobuf 协议。 简单对比一下二者的区别： 特性/包 trpc thrift 静态类型检查 支持，利用 TypeScript 的类型系统 需要手动进行类型检查和处理，不如 TypeScript 强大 编译过程 不需要显式编译，利用 TypeScript 编译器 需要将 Thrift 文件显式编译成目标语言的代码 运行时依赖 可能需要 TypeScript 运行时依赖 部分语言可能需要 Thrift 运行时依赖 社区支持 相对年轻，社区规模较小 相对成熟，有较大的社区支持 代码生成 利用 TypeScript 的自动生成功能 需要显式编译 Thrift 文件生成代码 开发体验 针对 TypeScript 用户友好，提供良好的开发体验 可能需要额外配置和步骤，不如 TypeScript 开发体验好 项目适用性 适用于 TypeScript/JavaScript 项目 适用于多语言项目 同时二者在 RPC 的协议上页有一定区别，这里页简单对比一下二者的区别： 特性/协议 Protobuf Thrift 序列化格式 二进制 二进制 语言支持 支持多种编程语言，包括Java、C++、Python等 支持多种编程语言，包括Java、C++、Python等 可读性 较小且二进制，不易人工阅读 二进制，不易人工阅读 性能 通常比JSON和XML更快 通常比JSON和XML更快 动态类型 不支持动态类型，需要先定义消息格式 支持动态类型，无需预先定义消息格式 扩展性 支持向后兼容性的版本控制 支持向后兼容性的版本控制 语法 使用.proto文件定义消息结构 使用IDL文件定义消息结构 字段标签 使用数字标签标识字段，更紧凑 使用字段名作为标签，可读性更好 社区支持 由Google维护，有较大的社区支持 由Apache维护，有稳定的社区支持 适用场景 适用于大规模数据交换和高性能要求的场景 适用于大规模数据交换和高性能要求的场景 发展趋势 2024 年后端和 Web 开发趋势 文章深入探讨了2024年后端和Web开发的关键趋势。首先，人工智能（AI）和机器学习（ML）在后端开发中的融合被强调，涵盖了代码生成、安全改进、个性化、预测分析和推荐引擎等方面，以提高开发效率。其次，Serverless Architecture 被认为将在2024年继续扩展，通过减少服务器管理，提高可扩展性和成本效益。Edge computing 作为新兴技术，被列为能够减少延迟、提高性能和实现实时数据处理的关键趋势。ZTA 架构的出现改变了传统的网络安全模型，强调验证身份、最小特权访问、微分割和数据加密等原则。物联网作为快速增长的软件开发趋势，涉及连接的物理设备通过互联网收集和交换数据，与云计算平台相结合构建可靠的后端系统。此外，对开发者健康的关注也体现在人体工程学键盘的推崇。最后，文章列举了2024年流行的编程语言和框架，包括 Rust、JavaScript、Python、Django、Node.js、Svelte和 Qwick。 工具推荐qnm 用于查询node_modules目录的 cli 工具我们经常需要快速检查 node_modules目录下安装的模块的版本。通常我们会运行 npm list 或者 yarn list 来进行查找，其运行速度很慢，而且会产生很多不相关的输出。qnm 是一个工具，它通过提供关于已安装模块的快速和集中的信息来解决这个问题。它同时支持npm和yarn，并允许你快速识别你感兴趣的模块的版本。 面试工具推荐马上又到了找工作的金三银四，准备迎接金三银四求职高峰了吗？接下来为大家推荐两款工具，希望对大家找工作有所帮助 rxresu.me 一个免费和开源的简历生成器，简化了创建、更新和分享简历的过程。 没有用户跟踪或广告，隐私是最优先考虑的。支持自主托管，可以在不到30秒的时间内自托管。 支持同时管理多份简历 实时编辑预览 丰富的排版模式 更多丰富的功能 如何高效的使用leetCode 通过对相似算法进行分类，找到各类问题的解决方案，培养将新的问题映射到已知问题的能力。文章收集了大约 20 个这样的编码问题模式，了解这些模式背后的想法，一旦你熟悉了一种模式，你将用它解决许多问题。详细的问题讨论可以查看Grokking the Coding Interview 经验输出试试这个来替换console.log文章列举了 console 的其它几类用法，在更合适的场景下采用对应的方法，而不是一昧的使用console.log。其中比较令笔者印象深刻的是，console.trace()，可以将方法的调用堆栈打印出来，这个在一些复杂调用的场景下会很有帮助。 12345678910111213function trace(){ console.trace()}function randomFunction(){ trace();}/* 输出console.trace- trace- randomFunction- (anonymous)*/ 前端 10 个最佳实践（React）从前端开发的角度出发，我们将聚焦于代码的工程结构和组织方式，逐步探讨工程化标准的建设。最终，我们将深入研究 React 的真实开发场景，重点关注如何有效实现UI与逻辑的分离。此外，在处理性能问题时，我们还将介绍一系列有效的手段。这篇文章旨在为前端开发者提供全面的视角，帮助他们在项目中建立清晰的代码结构，规范化工程流程，并在React应用中实现高效的UI与逻辑分离，同时掌握处理性能问题的有效方法。 Node 最佳实践经典的 NodeJS 最佳实践，2023 年新增 14 条最佳实践，更新 12 条最佳实践。快来看吧！)","link":"/2024/01/05/2024/0x20240105/"},{"title":"前端早读精选 - 第四期","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来 Node、Git 常用的技巧，在技术发展趋势上，探讨 Rust、Go、Node、Deno、Bun 多种技术在实际业务中的使用选择。工具方面，强推荐大家尝试一下 AI 提效工具。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐NodeJS 的一些开发技巧与性能优化手段 文章通过 Express 简单启动一个服务作为切入点，列举了常用的压力测试（ab、webbench、autocannon）、性能测试工具、debug工具（chrome devTool）。性能优化方面与内存管理，列举了一些常用的优化手段与内存管理方式。阅读大约 6 分钟，大家可以按需查漏补缺。 十个你应该知道的 Git 命令 Git是每个软件工程师必须知道的最基本的东西。这些工具是开发人员日常工作不可或缺的一部分，因为我们每天都与他们互动。精通Git不仅可以简化您的生活，还可以显著提高工作效率。在这篇博文中，我们将探索一组可以提高你的工作效率的命令。随着您越来越熟练地使用这些命令，您将节省宝贵的时间，并成为一名更高效的软件工程师。其中 git commit --amend -m 'msg' 很适合笔者这种直接用上一次命令快速commit的提交后，但是又想要改一下commit 信息，使其更符合这次提交的信息，又不想再修改文件的情况下使用，可以直接将最后一次的 commit 信息进行修改。也比较适合一个需求最后阶段做个总结的 commit 信息补充。 REST API 设计最佳实践 想了解 REST API 设计的原则，可以看一下这篇文章。阅读大约 4 分钟，文章阐述了 10 条设计 REST API 的最佳实践。 7 种”防御型编程“方式 当我拿出“防御型编程代码”，请问阁下将如何应对。文章列举了 7 种在日程编写代码种容易出现的编码陋习，并给到了更优的写法。快来看看自己的代码是否是这 7 种防御型代码。 2023 年最大技术分歧：选 Rust 还是 Go ？ 在 Stack Overflow 2022 开发者调查中，对于“让人爱恨交织的编程语言”这个问题，在 7 万份回复中，程序员们明显也更为偏爱 Rust，86% 的人表示喜欢 Rust，而 64% 的人表示喜欢 Go。面对 Rust 的火爆现状，一些开发者发出了灵魂提问：2023 年，Go 还值得学习吗？ 笔者选 rust！哈哈哈哈哈哈哈！ 2024 年你应该使用 Bun、NodeJS 还是 Deno？ 对于你下一个重要的 JavaScript 项目，应该选择什么呢？嗯，事情并不那么简单。理解每个运行环境的优势和劣势是很重要的。因此，本文通过比较 Bun、NodeJS 和 Deno，深入探讨它们的优点、缺陷等方面。 简单总结一下三者优缺点 优缺点 NodeJS Deno Bun 优点 1. 非阻塞 I/O 和可伸缩性提供了更高的性能 2. 成熟的生态系统，拥有众多的库和框架 3.庞大而活跃的社区支持 1. 安全性高 2. 天然支持 TS，开发体验更优 3. 通过 URL 简化模块管理 1. 学习曲线低，Bun 是一个全能的工具包 2. 使用JavaScriptCore 引擎，性能更高 缺点 1.单现成特性存在性能瓶颈，不适合CPU密集型任务 2. 容易陷入异步编程回调地狱 1. 生态不成熟 2. 三方库可用性有限 1. 社区支持有限，属于新推出产品 那么实际项目中，怎么选择技术方案？ Node.js：如果你更喜欢经过多年试验和测试的稳定可靠生态系统，那么这是首选的运行环境。 Deno：如果你优先考虑安全性和最新的编程环境特性，则建议使用 Deno。它还原生支持 TypeScript。 Bun：如果你需要高速度，特别是在使用 JavaScript 或 TypeScript 时，那么这个运行环境应该是你的首选。 Bun 作为一个新的轮子，并且荣获2023 最受欢迎第二名，可见社区对其的期待，想了解更新关于 Bun 的信息，可查看相关文档 工具推荐h5player 一个油猴视频增强脚本，支持所有H5视频网站，例如：B站、抖音、腾讯视频、优酷、爱奇艺、西瓜视频、油管（YouTube）、微博视频、知乎视频、搜狐视频、网易公开课、百度网盘、阿里云盘、ted、instagram、twitter等。全程快捷键控制，支持：倍速播放/加速播放、视频画面截图、画中画、网页全屏、调节亮度、饱和度、对比度、自定义配置功能增强等功能，为你提供愉悦的在线视频播放体验。还有视频广告快进、在线教程/教育视频倍速快学、视频文件下载等能力 oxlint更快的 Lint 工具 比 eslint 快 50- 100 倍的 lint 工具正式发布。在真实测试场景下，Shopify 报告称，他们需要 75 分钟的 eslint 检测，在使用 oxlint 后，仅仅只发给 10 秒。简单易用，可以在没有配置文件的场景下，在项目根路径下运行 npx oxlint@latest 即可。但 oxlint 尚未提供插件系统，所以暂时不支持 TypeScript、React、Jest、Unicorn、JSX-a11y 和 Import 等流行插件的规则。 笔者建议：如果当前项目 Lint 耗时并不是效率瓶颈，可以先保持观望一波！ mdcat 一个可以在命令行显示 Markdown 文件渲染后的内容工具。体验了一下，能够识别部分语法，但是想表格、勾选框这一类的没有识别 DOMPurify 专注于Dom 的 XSS 清除程序 DOMPurify 专注于消除 HTML、SVG 和 MathML 中的潜在恶意代码，通过在将用户提供的内容插入到 DOM 之前，清理和净化这些内容来防范 XSS 攻击。相较于 XSS在过滤 Dom 的场景下，DOMPurify 要更快，但在处理一些特定场景（如处理纯字符串）时不如一些通用的 XSS 过滤库灵活。简单来说，如果你主要关注在前端处理用户输入并防范 XSS，DOMPurify 是一个强大的选择，尤其是在处理 DOM 内容方面。如果你需要通用的 XSS 过滤功能，或者对性能要求不是特别严格，”xss” 包可能是一个更通用的选择。 everyone-can-use-english 一款使用 electron 创建的学习英语的软件。支持添加视频音频学习资料。同时还支持机器人对话翻译，单词本，打卡记录等多种功能。注意一点：启动项目后需要使用 Mixin-Messenger 进行登录，但是 Mixin-Messenger不支持国区，iOS 用户可以切换 AppStore 地区进行下载，笔者切换至土耳其下载成功，安卓用户可以使用 google-play 下载安装。 通过AI工具提升开发效率 文章推荐了几款在日程开发过程中，能够提升我们开发效率的AI工具，如Copilot、GPT-Engineer、Cody AI、React Agent、v0、Sweep AI、ScriptGPTGPT 工程师即将崛起！🤣🤣🤣","link":"/2024/01/19/2024/0x20240119/"},{"title":"前端早读精选 - 第五期","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来，WebCodecs web 新视频解码新方案、NodeJS 常用工具库、React 生态、Chrome 与 VSCode 小技巧等。工具方面，新一期的 AI 工具推荐、无需构建的前端框架-ofa、commit CI 小工具。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐WebCodecs 开启 Web 音视频新篇章 WebCodecs 提供访问编解码能力的接口，可精细控制音视频数据。通过 WebCodecs 可快速实现视频生产。相较于传统使用 JS或者 WASM 实现编解码能力，WebCodecs 提供了更高的编码性能，其编码速度可达到 ffmpeg.wasm 的 20 倍。在视频的消费侧，WebCodecs 支持缓冲延迟控制、逐帧播放、超快速播放、解码控制等。能够支持构建更强、体验更好的视频消费应用。同时在计算维度，能够实现算力成本转移，将服务端的视频转换成本放在用户本地运行，不仅降低了服务运营成本，还能提升用户体验。更多 Demo 体验 Node.js Power Tools: 13 Libraries Every Developer Should Know 文章列举了 NodeJS 日常开放中 13 个常用工具库，涉及数据库、网络请求、邮件、登录验证中间件、异步任务管理、日志输出等。 Use Chrome DevTools Like a Senior Frontend Developer 调试 Chrome 工具的小技巧包括如何迅速重新发送请求、复制 JavaScript 变量、使用快捷键选择 DOM 元素，屏幕快速截图或精准截图。此外，还能在调试过程中快速安装 NPM 包，以供进一步调试，同时在调试断点时添加条件判断，迅速定位问题所在。欲获取更详细的操作指南，请点击查看完整内容。 10个 VSCode 提效技巧–part1、part2 俗话说”工欲善其事，必先利其器“，文章介绍了 VSCode 在日常开发中的一些实用小技巧，快来看看有哪些你常用的操作可以被快捷替换的！ React awesome for 2024 让我们来了解一下，围绕 react 的生态库。包含 react 工程创建、包管理，数据状态、SPA 路由管理，UI库、动画库、组件库、单元测试、跨端等一系列生态建设。 简单而强大：这些场景无 JavaScript 也能轻松应对 Web 开发的第一核心原则就是“最小能力原则”。换而言之，也就是当我们实现目标时，应该选择相对较轻量的编程技术去实现。由于 HTML 和 CSS 的各项功能都是浏览器原生支持的，因此这些功能通常会有更好的性能、更原生、具备更好的用户体验，对可访问性的支持也更好。虽然并非所有的场景都优于 JS（特别是在可访问性方面），但大多数时候，利用浏览器原生功能来实现复杂逻辑，会给用户带来更好的使用体验。 或许换个角度看，可能很多场景我们并不需要前端框架，甚至JavaScript。从新的前端框架的趋势看，越来越多的框架抛弃繁重的框架设计，体现简约。比如最近大火的 htmx。虽然笔者并不看好 htmx，但从一些特定场景来看，htmx 确实更合适。关于 htmx 相关推荐： Htmx 意外走红，我们从 React“退回去”后：代码行数减少 67%，JS 依赖项从 255 下降到 9、 AHA：结合 Astro、htmx 和 Alpine.js 创建通过网络发送 HTML 的现代 Web 应用程序 工具推荐no-build framework - ofa 基于 Web Components，不需要打包的 MVVM 框架。无需繁琐学习，无需 npm、nodejs、webpack，即刻上手。这让笔者想起了 DHH 先前的言论：”前端不再需要构建”。各位同学，你们怎么看待这件事呢？相关信息：前端根本不需要构建！“技术邪教” Ruby on Rails 之父再出激进言论引争议、DHH 锐评 “打包工具”：前端根本不需要构建 (No Build) better-commits 你是否还在为 commit 信息不准确而烦恼，那么 better-commit 将会是一个不错的选择。很多时候，我们为了快速提交，commit 信息会写的很粗略，这样在后续翻找历史代码时，无法直接从 commit 看出当时的改动是为了干什么，只能通过阅读代码来猜测当时的想法。好的 commit 不仅能够帮助自己记录改动说明，也能帮助他人更好的帮你 review 代码。 10个免费的 AI 网站 AI 降噪：https://podcast.adobe.com/enhance 人声消除器：https://vocalremover.org/ 音乐伴奏自动生成 室内设计： https://www.roomgpt.io/ 内容创作者：https://rytr.me/Rytr 是一款人工智能写作助手，可帮助您在短短几秒钟内以极低的成本创建高质量的内容。 脚本转换视频：https://studio.d-id.com/ 文生图：https://leonardo.ai/ 创作无版权音乐：https://soundful.com/ 使用 Adob​​e Firefly 创建和编辑图像: https://firefly.adobe.com/ 使用 AI Meme Generator 将文本转换为 Meme: https://www.supermeme.ai/ Scribble Diffusion：使用 AI 将草图变成精致的图像： https://scribblediffusion.com/ 更多推荐培养写作习惯的4种简单方法 改变自己的心态：为了什么而写作，不去考虑结果，而是去感受这个过程。“*Don’t think in terms of the outcome but your identity and process.*” 有意识的暗示：当碰到有感触的事情，可以记录下来，潜意识的告诉自己，希望能够将对自己有感触的事情分享出去。 即时激励，用有吸引力的写作奖励来激励自己。写作过程中并没有多少多巴胺，但按下发帖按钮却涉及到了。完成一项具有挑战性的任务并取得进展的感觉也是令人欣慰的，你可以通过有意识地认识到这种感觉并记住你正在使你的身份变得更加强大，从而将这种感觉联系起来更强烈。 让写作尽可能顺畅：让写作融入你的生活。 2023 年终总结 你的年终总结写好了吗？不妨让我们来看看其他同学的年度总结吧！项目汇总了 221（持续更新中） 篇年终总结，大家可以挑选自己感兴趣的博主去看看他这一年的年终总结 Web3 游戏在2024的七个预测 本文深入探讨了 Web3 游戏行业的 7 个关键预测。Web3 游戏的未来取决于其提供引人注目且独特的游戏体验、超越市场趋势和投资者优先事项的能力。早期的 NFT 确实存在很大的投机属性，文章预测不可替代代币（NFT）在游戏行业中的作用正在经历重大转变。 NFT 不再仅仅是投机资产，它正在被重新设想为商业模式中的基本要素。各位同学怎么看，欢迎大家踊跃讨论留言。","link":"/2024/01/26/2024/0x20240126/"},{"title":"前端早读精选 - React 2024 RoadMap、2024 你应该关注的前端框架","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来，React 2024 RoadMap、2024 你应该关注的前端框架、手把手教你如何完成一个开源库的完整流程、利用 qwik 替换react开发微型项目、react-native 对 Apple Vision Pro 支持；工具方面，融合多个 AI 工具的GUI软件 - Noi、AWS 新的 JS runtime - LLRT、迷宫、地形和角色的JavaScript程序生成器 - Labyrinthos。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐What We’ve Been Working On – February 2024 React 团队 2024 RoadMap。其中 React Compile 取得了不错的进展，在 Instagram 生产环境中已经落地。React Compiler 能够通过对 JavaScript 规则_和_“React 规则”进行建模来安全地编译代码，从而提高性能。同时也会有相应的语法限制，通过启用严格模式并配置 React 的 ESLint 插件来捕获 React 代码中的细微错误，提高当前应用程序的质量，为后续适配 React Compiler 提供基础。React 正在探索使用服务器操作将数据从客户端发送到服务器的解决方案 – Actions。action函数可以同步或异步操作，并且&quot;use client&quot;和&quot;use server&quot;来们标记代码的执行环境，&quot;use client&quot;指示会生成&lt;script&gt;标签（如Astro Island），同时&quot;use server&quot;告诉捆绑器生成 POST 端点（如tRPC Mutations），不会将代码打包到JS bundle 中。想要体验上述的部分新功能，可以使用 React Canary，目前 Actions 的能力已经集成到 Canary 版本中。由于当前很多新功能将会是一个breaking change，所以 react 的下一个版本将会是大版本升级 React V19。最后还有一个小的改动，将Offscreen 重新命名为Activity。“Offscreen”这个名称意味着它仅适用于应用程序中不可见的部分，但在研究该功能时，React 团队意识到应用程序的某些部分可能是可见的和不活动的。新名称更准确地反映了将应用程序的某些部分标记为“活动”或“非活动”的行为。 React、Angular、Next.js、Solid 创建者告诉你，2024 年你需要关注哪些框架！ 在The New Stack上讨论了主要JavaScript前端框架如Angular、Next.js、React和Solid的未来计划和发展。每个框架关注不同的方面： Angular：强调更精细的反应性和使Zone.js可选，这将导致更快的加载时间和初始渲染。 Next.js：计划简化缓存，提高性能，并引入新的编译器以加快工具操作速度。 React：旨在扩大对React Server Components的采用，并继续开发新功能，如React Forget和Static Hermes。 Solid：预计将发布SolidStart 1.0和Solid.js 2.0，专注于基本原语，并提供一个可更换部分的元框架，以提供更大的灵活性。 附 Static Hermes 的一些信息Static Hermes 是 Hermes 引擎的下一代版本，它在 Hermes 的基础上增加了静态类型检查和提前编译功能，从而进一步提高了 JavaScript 代码的性能。 静态类型检查：Static Hermes 可以对 JavaScript 代码进行静态类型检查，从而发现潜在的类型错误并防止其在运行时发生。这可以提高代码的可靠性和安全性。 提前编译：Static Hermes 可以将 JavaScript 代码提前编译为原生机器代码，从而提高代码的执行效率。Static Hermes 的主要优势在于： 更高的性能：Static Hermes 可以将 JavaScript 代码的执行效率提高到与 C/C++ 代码相当的水平。 更小的代码包：Static Hermes 可以将 JavaScript 代码包的大小缩小 20% 到 50%。 更强的安全性：Static Hermes 可以通过静态类型检查来防止类型错误的发生。相较于 Hermes，Static Hermes 更侧重于编译时，除了更好的性能与安全性也会带来一定的语法限制。更多信息参考 如何使用 TypeScript、测试、GitHub Actions 发布包并自动发布到 NPM 文章阐述如何用 TypeScript 编写一个库与对应的单元测试，并将编译后的代码、类型在包中发布。使用 github Action 完成 CI 构建测试流程，最后发布到 NPM。还在本地发包的同学，不妨参考一下该自动化流程。 在Astro中使用 Qwik 替换 react 针对一些轻量级的web项目。使用 Astro构建，默认情况下，它向客户端发送零 JavaScript — 对于快速、轻量级和高性能的内容网站来说非常出色。但有时，我需要一些客户端 JavaScript 来实现交互性。此时，我发现自己很难在普通的 Vanilla JavaScript 还是 React 之间做出选择。一方面，Vanilla JavaScript 通常比 React 更轻量级，但它可能变得难以维护。 React 在某种程度上解决了这个问题，但对于最小的客户端 JavaScript 需求来说，它太重。这个时候不妨考虑一下 react 的替换方案 – Qwik。 announcing-react-native-for-apple-vision-pro React Native 现已在 Apple Vision Pro 上可用，为开发人员释放了该平台的全部潜力。与兼容模式不同，这种方法可以在visionOS上实现沉浸式体验和XR功能。还在等什么，花 $3000 上车 Vision Pro 🐶🐶🐶 工具推荐Noi 集成了多款 AI 应用的 GUI 程序。 LLRT LLRT 是一种实验性的轻量级 JavaScript runtime，旨在满足对快速高效的无服务器应用程序不断增长的需求。与 AWS Lambda 上运行的其他 JavaScript 运行时相比，LRT 的启动速度提高了 10 倍以上，总体成本降低了 2 倍。它采用 Rust 构建，利用 QuickJS 作为 JavaScript 引擎，确保高效的内存使用和快速启动。目前可以通过配置 Lambda functions 来使用LLRT。但需要注意的是，LLRT 仅支持一小部分 Node.js API。它不是 Node.js 的替代品，也永远不会。LLRT 适用与对性能要求较高的函数，因此不建议将有 node_modules 依赖的函数进行部署。 Labyrinthos 一个用于迷宫、地形和角色的JavaScript程序生成器。专为游戏开发者和专业爱好者，迷宫。js 提供了一个非常简单易用的API来制作复杂的，可定制的景观 更多推荐史上最快大模型炸场！Groq一夜爆红，自研LPU速度碾压英伟达GPU 还没消化完Sora带来的震撼，又一家硅谷初创企业带着史上最快的大模型和自研芯片LPU霸占了热搜。英伟达的挑战者Groq登场！抛弃GPU，自研LPU！文本生成速度比眨眼还快！推理场景速度比英伟达GPU快10倍，但价格和耗电量都仅为后者十分之一。笔者体验了一下，快是”挺快“的，但是问题回答的准确性有待提高。😂😂😂 附：LPU 相关信息LPU是一种较新的概念，专门为机器学习和人工智能应用设计。它们旨在优化深度学习运算和算法。对于专注于深度学习和AI的项目，LPU可能是一个更高效的选择。然而，对于需要更广泛应用和灵活性的场景，GPU可能是更好的选择。 设计用途：LPU是一种较新的概念，专门为机器学习和人工智能应用设计。它们旨在优化深度学习运算和算法。 应用领域：LPU主要用于深度学习、神经网络训练、数据分析等领域。 技术特点：与GPU相比，LPU可能有更专门化的架构，专门针对深度学习的运算需求，比如更快的矩阵乘法和更高效的数据流管理。 因为360，火绒干掉了win 10的电脑桌面。 什么！好端端的我的桌面被干掉了！一场来自操作系统与热门软件间的趣事！","link":"/2024/02/23/2024/0x20240223/"},{"title":"前端早读精选 - 前端年度盘点与未来展望、霸榜 GitHub Trending 的12306抢票工具第六期","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来，来自腾讯的2023前端年度技术盘点与2024技术展望、深度剖析正则原理、新的前端图片格式 -avif、以及css与前端轮训小技巧。工具方面，带来近期霸榜 GitHub Trending 的12306抢票、前端代码查重工具、google 网页索引工具与对shell更友好的bun-shell。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐穿越时空：2023年前端技术盘点与2024年技术展望 2023 年在前端行业发生的一些重要事情： 语言与标准：CSS、ES 和 TS 语法持续完善，社区竟现反 TS 声音 前端框架：主流框架持续完善，黑马 Htmx 与 Qwik 异军突起 前端基础建设：多种语言助力前端基建的持续发展 Chrome 浏览器：加强对用户数据安全的保护 低代码：持续完善的低代码引擎开源社区 D2C：C2D2C 亮相，大模型赋能 D2C 未来可期 大模型：大模型应用能力持续完善与落地 跨端：鸿蒙应用开发为跨端带来新变化 WASM: 未来将与更多语言和场景结合 音视频：传统编解码与 AI 编解码并驾齐驱 对于未来技术展望 大模型持续为前端赋能 拥抱 TypeScript 是前端语言与标准的主旋律 探索更好服务端渲染是前端框架的大势所趋 Rust 是前端基础建设的未来 鸿蒙入局，跨端三分天下格局指日可待 TypeScript 依然是前端语言与标准，虽然社区最近对于 TS 的看法各不一样，但是从目前的笔者负责的业务场景看，TS 依然是最佳选择。关于 C2D2C，笔者也抱有期待。通过前端标准化组件与设计标准结合，设计师基于现有组件库输出设计稿，前端研发拿到对应设计稿再转换为可执行代码。由于设计稿和代码使用的是同一套设计系统，设计稿中的组件和最终代码中的组件是一一映射的关系，因此无需进行标注就可以实现组件的精准识别。同时在代码的二次可发与可读性上也会得到很大改善。强势崛起的Qwik也是一个值得关注的框架：号称历史上第一个 O(1) 的前端 SSR 框架。如果你对其 SSR 性能感兴趣，可以通过这篇文章了解。👉🏻点击查看👉🏻阅读全文了解更多内容 为什么 2024 年应该使用 AVIF 而不是 JPEG、WebP、PNG 和 GIF avif 对比传统的图片格式，在压缩效率、颜色深度有着明显的优势，但在编解码的效率上相对低一些。不过在新的浏览器环境下尝试 avif 未尝不是一个好的选择。附：avif 与 webp 对比 特性 AVIF WebP 压缩效率 高（更小的文件大小，保持高质量） 较高但通常不如AVIF 图像质量 支持更广泛的颜色范围和动态范围，适合高分辨率图像 良好，但在颜色和动态范围上不如AVIF 浏览器兼容性 相对较新，支持不如WebP广泛 几乎所有现代浏览器支持 编解码速度 编码较慢 编码和解码速度较快 功能支持 支持高动态范围（HDR）和透明度 支持透明度，有损和无损压缩，但在HDR上支持不足 应用场景 适合对图像质量有高要求的应用 适合需要快速处理和广泛兼容性的应用 浅谈正则表达式——从原理到实战 这篇文章是关于正则表达式的深入讨论，从基本语法到实际应用全面介绍了正则表达式的各个方面。内容包括正则表达式的组成、不同类型的字符和匹配模式、贪婪与非贪婪匹配的概念以及它们在性能上的影响。文章还探讨了捕获组、匹配模式和前瞻/后顾断言的概念。最后，讨论了正则表达式的底层原理，特别是非确定性有限自动机（NFA）和确定性有限自动机（DFA）在处理正则表达式时的差异。想要深入了解正则的同学，点击阅读全文 JavaScript WTF: Why does every() return true for empty arrays? 文章从数学的角度探讨为，什么当数组为空数组时，[].every(item =&gt; true) 会返回 true, [].some(item =&gt; true)，会返回 false，这一表现是否符合你的直觉。 every: It is vacuously true that all elements of the empty set satisfy any given condition some: The “exists” quantifier states that the result is false for any empty set. the-surprising-things-that-css-can-animate 当您想到动画 CSS 属性时，您会想到哪些？文章列举了一些通常与动画无关的属性，用 CSS 可以实现的一些意想不到的动画效果，以及通过动画效果可以实现的一些巧妙的效果来实现动画。 一个健壮的前端轮询 文章讨论了在不使用websocket做服务端推送的情况下，如何写出一个健壮的前端轮询。文章提供了一些常见的前端轮询的应用场景以及可能遇到的问题，并逐一给到了解决方案。 笔者从文章中衍生一个场景，当列表筛选时，每次筛选项的变化，都需要前端重新请求。但是前端筛选项 UI 变化不依赖 API 数据返回，如果此时用户操作过快，同时存在多个筛选请求时，也需要考虑到请求废弃的问题，同样可以借助文章中的思路去解决。 工具推荐py12306 还没买到票的同学看过来！一款12306 购票助手，支持集群，多账号，多任务购票以及 Web 页面管理。支持本地部署，快来试试吧！ 前端代码重复度检测 听说过论文查重，那阁下是否听说过代码查重？在前端开发中，代码的重复度是一个常见的问题。重复的代码不仅增加了代码的维护成本，还可能导致程序的低效运行。为了解决这个问题，有许多工具和技术被用来检测和消除代码重复。其中一个被广泛使用的工具就是jscpd。 google-indexing-script 使用此脚本可让你的网站在 48 小时内在 Google 上建立索引。无需任何复杂技巧或黑客手段，只需简单的脚本和 Google API 即可。注意： 脚本并不会帮助你的网站在 Google 上的排名，只会让 Google 知道你的网站存在。 脚本使用到 Google Indexing API。虽然不能绝对保证每个页面都被索引到，但最近在 2023 年 12 月测试显示有非常高的成功率。 the-bun-shell bun-shell 提供性能更优，操作更简洁的 shell 集成命令，同时也解决了在 JS 中跨平台运行的兼容性问题 更多推荐高德地图官方首度揭秘：红绿灯倒计时功能是如何实现的？ 近日，高德地图官方发布视频首度揭秘了**“红绿灯倒计时读秒”功能背后的实现原理，那就是依赖过往车主的行驶启停规律，运用云端大数据算法推算出具体红绿灯读秒时间，甚至路口临时设置移动式红绿灯**，虽然没有接电和接网，但高德地图依然会显示红绿灯倒计时状态。笔者曾一度以为高德的红绿灯读秒是接入了交通数据。 GitHub的榜一大佬晒出存款后，大家却想给他捐钱 Sindre 是 Github 上拥有最多 Star 的个人。其 Star 个数甚至比阿里巴巴还要多。Sindre 甚至被称为 npm 之神，因为大家用的 npm 包大概率底层直接或间接都依赖了他的软件包。想要了解大佬，👉🏻点击查看 附：gitstar-ranking","link":"/2024/02/02/2024/0x20240202/"},{"title":"前端早读精选 - web 拦截技巧、NodeJS 2023工作总结、NextJS VS Remix","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来，Web 终极拦截技巧，通过hook完成各类神奇的事情、NodeJS 2023 工作总结、NextJS 与 Remix 全方面对比、overflow 使用小技巧；工具方面，强烈推荐翻译软件：沉浸式翻译。阅读英文文章的不二之选！、独立开发者出海工具指南。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐Web 终极拦截技巧在Web开发中使用的一些高级拦截技巧。文章内容包括如何拦截和重写浏览器API、操作事件和DOM元素，以及使用ServiceWorkers和服务器端拦截。此外，文章还探讨了这些技术的实际应用，例如创建沙箱环境和开发通用域名服务。 笔者附录： 很认同文章开头的一句话：计算机科学领域的任何问题都可以通过增加一个中间层来解决。 —— Butler Lampson。但是在解决问题时增加中间层，更多的是一种临时或者 hack 的解决方案，并不是大部分场景的最佳解决手段。 在做系统功能拦截时，必要的安全问题也需要考虑。对于代码嵌入，常用的攻击手段，如：XSS、原型污染。关于XSS 攻击手段，想必各位同学都比较了解。这里简单补充一下原型链污染：它发生在攻击者通过修改一个对象的原型（即对象的__proto__属性或通过其原型链）来添加或修改属性时。当这个被污染的原型被应用程序的其他部分使用时，可能会导致意料之外的行为或安全问题。比较知名的攻击事件：lodash.defaultsDeep 方法造成的原型链污染 nodejs-2023-year-in-reviewRafael，Node.js技术指导委员会成员和Fastify核心团队成员，分享了关于过去一年Node.js演进的有用更新，团队如何确保Node.js经过了充分的测试并且可靠，Node.js外部依赖的变化（在2023年新增了三个），以及Node.js安全性和Web存在方面的增强。 笔者附录：NodeJS 新的吉祥物：Rocket Turtle Next.js vs. Remix: A Developer’s DilemmaNext.js vs. Remix： A Developer’s Dilemma — 比较了各个领域，从各种技术的实现方式到部署、支持和受欢迎程度。 使用 overflow: clip 替换 overflow: hidden 驱动滚动动画当使用animation-timeline: scroll(nearest) 来实现滚动动画时，因为 overflow: hidden 会创建一个滚动容器，它可能会干扰到滚动驱动动画的滚动查找机制。使用 overflow: clip 能有效的规避这个问题。overflow: clip 与 overflow: hidden 的表现形式类似，区别点在与 clip 不会创造滚动容器，且无法通过 JS 改变滚动属性来实现滚动。 笔者附录： 关于 animation-timeline 属性，提供一种更细粒度的控制方式来协调复杂的动画序列，使得开发者可以更精确地安排动画的执行顺序和同步。如上述例子中的animation-timeline: scroll(nearest)，会根据滚动容器的 scrollTop 去驱动滚动动画百分比。但需要注意的是，当前这个属性还属于实验阶段，更多信息 工具推荐沉浸式翻译沉浸式网页双语翻译扩展，支持PDF翻译，双语Epub电子书制作，Youtube/Netflix/Udemy 等平台双语字幕，支持Deepl/Google等多个翻译服务，免费使用。一款免费的，好用的，没有废话的，革命性的，饱受赞誉的，AI 驱动的双语网页翻译扩展，帮助你有效地打破信息差，在手机上也可以用！同时推荐给大家一个使用 AI 翻译时，价格更便宜的接入方式：aihubmix indie-hacker-tools出海第一步，搞定工具库。仓库收录了独立开发者出海技术栈和工具，持续整理中……仓库收录标准： 帮助独立开发者提升开发效率 帮助独立开发者降低成本 市场上足够流行 更多推荐职场焦虑症｜如何做自己的思想工作？本文作者根据十年工作经验分享了一些关于职场焦虑症的故事，还有一些应对技巧。希望大家在新的一年，开会不吵架，做项目不倒排。 在 GitHub 上发现超过 100,000 个受感染的存储库国外安全研究和数据科学团队发现，去年年中开始的恶意仓库混淆活动出现了复苏，这一次的规模更大。这次攻击影响了超过100,000个GitHub仓库（推测还有数百万个），当不知情的开发者使用看似已知且可信的仓库，实际上这些仓库却被恶意代码感染。","link":"/2024/03/01/2024/0x20240301/"},{"title":"前端早读精选 - CSS 单位全梳理、Performance API 指南、V8 引擎最新更新摘要","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来，CSS 布局单位梳理、如何使用 Performance 打造自己的性能报告、V8 引擎最新更新摘要、如何更好的实现音频倍速播放；工具方面，新的效率神器-&gt;基于截图或网页链接AI自动生成代码、基于图片生成音乐的 AI 工具、上古 NodeJS 框架–Express，迎来新的迭代、Mac 自带图片处理小工具；行业新闻方面，对于现代网站不断膨胀的JS代码的探讨、AI 行业到底有没有护城河。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐CSS 基于容器的相对布局单位虽然当前有很多可用的 CSS 单元，但在日常开发过程中，主要还是像素和 （r）ems 来调整大小和字体。随着CSS规范不断迭代，新的单位属性越来越多，是时候好好整理一下这些单位的含义了。该系列总共分为三部分，本篇文章是第三部分，探讨了CSS中基于容器的长度单位，这是一个新的概念，允许开发者根据元素的容器大小来定义尺寸和间距，而不仅仅是依赖于像素或相对于视口的单位。作者通过实例演示了如何使用这些单位（如cqw和cqh）来创建更灵活和适应不同屏幕尺寸的布局。这些单位提供了一种新的方法来思考和实现响应式设计，使得组件可以根据其父容器的大小动态调整样式。前两部分内容请查阅：第一部分-基于字体的相对布局单位、第二部分-基于窗口的相对布局单位 附：基于容器的相对布局单位简单总结 cqw：容器查询宽度（Container Query Width） cqh：容器查询高度（Container Query Height） cqi：容器查询内联尺寸（Container Query Inline-Size） cqb：容器查询块尺寸（Container Query Block-Size） 注意：如果父容器定义了具体的宽度，那么 cqw 与 cqi 的表现形式是一样的。在 flex 布局中，cqi 等于 flex-basis 的值，而在 grid 布局中，cqi 等于 column-width 的值 如何使用性能 API 报告核心 Web 指标这篇文章介绍了如何使用Performance API来报告核心网络体验指标（Core Web Vitals）。Performance API是一套标准，用于通过JavaScript测量和评估性能指标，能够直接在DOM中生成性能指标，为开发者创建自己的报告提供便利。文章还探讨了新的核心网络体验指标——交互到下一次绘制（INP）的测量方法，该指标将在2024年3月替代首次输入延迟（FID）。 V8 JavaScript 引擎的最新更新摘要V8 是全球最流行的 JavaScript 引擎，支持 Chrome 和 Node.js 等技术。V8 的开发速度令人印象深刻，每天有多个代码提交，大约每个月都有主要版本。文章探讨了 Google 对 V8 的最新改进与补充。更多V8 迭代信息，可查看V8 2023 全年总结 不改变音调情况下Audio音频的倍速合成JS实现快节奏的生活，让大家在观看长视频时，时常会开启倍速播放，大家是否想过，当倍速播放时，音频如何尽可能的还完原有音调。如果你也有类似的问题，不妨来看看张鑫旭大佬的解决方案。 工具推荐截图生成代码这个简单的应用程序可以将截图转化为代码（HTML/Tailwind CSS，或React或Bootstrap或Vue）。它使用GPT-4 Vision（或Claude 3）来生成代码，并使用DALL-E 3生成相似的图像。现在，你也可以输入一个URL来克隆一个现有的网站。 基于图片生成音频的AI工具一款基于图片生成音频的AI工具，只需要上传图片就可以根据图片的特点生成对应的音乐。 捕捉到了熊猫的快乐精神，文本的文化背景以及点赞的大拇指，最后以欢快欢快的旋律，充满弹性的钢琴，欢快的弦乐和欢快的木管乐器，融入了二胡和琵琶等中国传统乐器输出音频， expressjs号外！号外！上古 NodeJS 服务端框架发布新版本了！！！Express经过了十六个月，迎来了一个新版本。本次更新是一次小版本更新，主要是对历史 bug 的一些修复。话说现在有同学在使用 Express 开发么？大家对 Express 怎么看，欢迎大家在评论区踊跃讨论！ sips：Mac 自带的可编程图形处理系统如果你想把 Mac 上一些 .webp 的图片转换为 .png，那么你可以直接使用 sips。sips 是 mac 上默认的系统命令，除了简单的命令行处理外，它还支持编写 JavaScript！！! 更多推荐不断膨胀的JavaScript文章讨论了2024年前端开发中JavaScript的膨胀问题，通过各种类型的网站（如社交媒体、电子邮件、视频平台等）的实际JavaScript文件大小，揭示了即使是基本功能也可能需要大量的JavaScript代码。作者发现，许多网站的JavaScript大小远远超出了合理范围，例如，谷歌邮箱页面可能需要高达20MB的JavaScript。这种趋势不仅增加了网页加载时间，还影响了浏览器的解析和执行效率，进而影响用户体验和设备电池寿命。作者认为，网站的内容应该比代码更重要，呼吁开发者优化代码以减少不必要的JavaScript膨胀。 作者分析完这么多网站，发现有一个网站做的很好。那就是 jQuery 官网 谷歌研究员：“我们的AI没有护城河，OpenAI也没有”谷歌内部正在讨论，如何应对 OpenAI 公司的 ChatGPT。这个研究员提出自己的看法：即使谷歌全力投入，可能也赢不了这场 AI 竞赛。原因如下： 生成式 AI 的核心技术是开源的，任何人都可以获取。 AI 模型的替代性很强。 AI 的核心竞争力在于算力和训练语料。 AI 的研究人员是流动的。","link":"/2024/03/08/2024/0x20240308/"},{"title":"前端早读精选 - Tauri 替换 Electron？用 CSS 实现优雅实现提示框","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。文章方面，本期为大家带来，为什么用 Tauri 替换 Electron做桌面软件、如何用 npm+typescript打造完善的monorepo仓库、神奇的CSS实现各类花式提示框、2024了，你该知道的git命令；工具方面，黄仁勋“几乎每天用”的搜索引擎 – Perplexity、AI图片处理工具：image-tools、nvm GUI工具；行业新闻方面，腾讯技术专家总结 15 年工作经验、星舰又炸了，但这也最成功的一次。话不多说，详细内容请大家查阅。如果觉得有收获，动动大拇指点个赞，以示鼓励！ 文章推荐为什么选择Tauri 替代 Electron 做桌面应用文章深入分析了Electron与Tauri在开发桌面应用方面的对比。Electron，虽然广受欢迎，但因其较大的应用体积和较慢的性能遭到批评。相比之下，Tauri以其轻量级和高性能获得优势，主要使用Rust语言，提供了更高的效率和安全性，尽管存在学习挑战。作者选择Tauri的核心原因包括更小的应用体积、更快的性能和更高的安全性，这些特性使Tauri成为构建现代桌面应用的理想选择。笔者体验过两款框架的开发，在易用性上 Tauri 确实对新手比较好，能够很快上手，但缺点也很明显，Tauri 对系统API 支持的丰富度与社区丰富度上，跟 Electron 相比，确实还有较大差距。 使用 npm + TypeScript 打造 monorepo 仓库文章详细阐述了如何结合npm和TypeScript在monorepo项目中实现高效的依赖管理和模块化构建。通过引入npm工作区，作者展示了如何优化项目结构，使不同的包能够共享依赖，同时保持各自的独立性。此外，文章还提供了关于配置TypeScript来支持monorepo结构的指南，包括设置共享的tsconfig基础配置和解决跨包引用的方法。这种方法旨在提高开发效率，简化项目维护，并优化构建过程。 用CSS实现提示气泡针对功能点的提示气泡，是业务开发过程中，常见的需求之一。如何在最小的标记与最大的灵活性的前提下使用 CSS 来完成功能开发呢？文章介绍了 clip-path，border-image 结合 CSS 变量的方式去实现各种复杂场景的气泡功能，同时尽可能的保持灵活性。该系列文章分为两部分，第一部分主要讲述基本的实现功能， 第二部分将探索更多场景下的提示气泡的实现方式。 更好用 git 新命令介绍了几个现代化的Git命令和功能，包括git switch和git restore（自Git版本2.23开始引入），用于切换分支和恢复文件的最后提交版本；git sparse-checkout（自Git版本2.25引入），用于在大型仓库中高效地检出子目录；以及git worktree和git bisect，分别用于管理多个工作树和通过二分查找定位引入错误的提交。 工具推荐perplexity黄仁勋“几乎每天用”的搜索引擎 – Perplexity。Perplexity自称为“世界上首个对话式搜索引擎”，核心使命是：挑战谷歌在搜索引擎领域的主导地位。与谷歌传统搜索引擎不同，Perplexity并非简单给出网站链接，而是运用先进的人工智能模型，针对用户的搜索问题提供直接、精准的答案，这种模式提升了搜索效率，也使得搜索过程更为智能；而与ChatGPT等生成式AI相比时效性更强、可溯源。 AI-image图片处理工具，支持通用抠图、人像抠图、背景替换。 通用抠图：处理输入图像中的主体，支持商品、人物、动物、植物、汽车等，无需任何额外输入，实现端到端的通用抠图并输出四通道抠图结果， 人像抠图：处理包含肖像的输入图像，无需任何额外输入，实现端到端的肖像抠图，并输出四通道图像抠图结果 背景替换：输入一张肖像照片和背景图片，即可生成抠图结果并更改背景，一键完成！ nvm-desktop不习惯使用 NVM CLI，那不妨试试 nvm 的 GUI 软件。 更多推荐入行 15 年，我还是觉得编程很难程序员的职业成长，可能是诸多行业中最难的那一批了： 校园时学的计算机理论，工作了几乎用不上； 技术的革新太快，轮子还没精通就被时代淘汰； 虚拟环境总是顺风顺水，一上生产环境就劫难重重； 面试时候要求造核弹，工作以后拧螺丝，聊绩效时说没有造核弹的思考； 觉得技术是最重要的，又觉得只会技术走不远，于是既丢掉了对技术的追求，也没学会对业务的思考； ……写代码很简单，写好代码很难；编程的精髓是“创造”；技术很重要，但“人”也许更重要；程序员最大的敌人是什么？ 马斯克的星舰又炸了，但这是最成功的一次目前为止最成功的星舰试飞，目标打卡 2 个半","link":"/2024/03/15/2024/0x20240315/"},{"title":"前端早读精选 - E2E 测试框架Playwright终极指南、2024 react 工具指南、注意NPM依赖安装风险","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：本期为大家带来，E2E 测试框架Playwright使用指南、npm依赖安装风险解析、2024 react 工具指南、TS 中 interface 与 type 使用区别、10 个你应该知道的 VSCode 使用技巧； **工具推荐**：更轻量更快的模板引擎 - eta.js、完全开源的高效复现类Sora视频生成方案 - OpenSora **行业新闻**：李彦宏“程序员将不再存在”、全球首个AI程序员诞生 Devin 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐Playwright视觉测试终极指南这篇文章是关于如何使用 Playwright 进行视觉测试的终极指南，详细介绍了视觉测试的概念、好处、实施步骤以及最佳实践。通过视觉测试，可以自动验证应用的视觉一致性，捕捉到其他测试方法可能忽略的界面问题。文章详细说明了如何设置和运行视觉测试，包括如何创建和比较快照，以及如何在持续集成/持续部署（CI/CD）流程中应用视觉测试。 延伸阅读： Playwright 和 Cypress 主要区别及优缺点如下： 浏览器支持：Playwright 支持多浏览器（Chrome, Firefox, Safari, Edge），Cypress 主要支持 Chrome, Firefox, Edge。 运行模式：Playwright 支持无头和有头模式，Cypress 主要是有头模式。 网络控制：Playwright 提供更强的网络请求拦截和模拟能力。 并行测试：Playwright 内建支持并行测试，而 Cypress 需要额外配置。 社区和生态：Cypress 由于较早发布，拥有更成熟的社区和插件生态。 综上 Playwright 的优点在于其跨浏览器支持和强大的测试功能，但社区相对较新。Cypress 用户界面友好，易于上手，具有稳定的社区支持，但在浏览器支持和高级测试功能上可能不如 Playwright。 👉 原文链接：Playwright视觉测试终极指南 npm 安装脚本风险在安装依赖时，是否有考虑这个开源的包所带来的副作用？文章探讨了npm安装脚本如何被武器化，通过一个有害npm包的实例展示了这种风险。以一个具体的例子介绍了恶意包的工作原理，如何通过preinstall脚本执行危害行为，并讨论了npm安装脚本的正当用途和潜在危险。同时，提供了防范建议，比如使用--ignore-scripts选项，以及利用自动化工具进行依赖分析和执行策略。 延伸阅读：Deno 在安全性的考虑上要比 Node、Bun 更为严格一些，Deno 默认不允许运行时访问外部资源（如文件系统、网络等）除非明确授权，这减少了恶意代码执行的风险。Deno 也不使用 npm，而是直接从 URL 导入模块，这改变了包管理的方式，避免了 npm 中存在的一些安全隐患。 👉 原文链接：npm 安装脚本风险 React Libraries You Should Use In 2024文章概述了2024年值得使用的React库，包括开发框架（如Vite和Next.js），包管理器（如NPM和Bun），CSS/UI库（如Tailwind CSS和ShadCN），状态管理（推荐Zustand），数据获取（如Tanstack Query和SWR），路由（React Router和Tanstack Router），认证（如Supabase和NextAuth），数据库与ORM（推荐SQL和Prisma），日期时间处理（如date-fns和day.js），表单处理（推荐React Hook Form），拖放功能（推荐DnD Kit），移动应用开发（如React Native和Expo），以及部署（推荐Vercel）。如果你有一个没有历史包袱的 React 工程，不妨考虑这些实践。 👉 原文链接：React Libraries You Should Use In 2024 TS 中 interface 与 type 使用区别这篇文章介绍了TypeScript中interface和type的使用区别。它讲述了两者的核心功能和使用场景，其中interface主要用于定义数据结构，且可以合并多次声明，而type可以表示不同类型的组合，但不支持合并。这篇文章旨在帮助开发者有效地在TypeScript开发中选择合适的构造使用。 👉 原文链接： TS 中 interface 与 type 使用区别 10个VSCode 技巧提升你的研发效率这篇文章为VS Code用户提供了十个提高生产力的关键技巧，如使用多光标编辑、利用代码片段快速编程、定制工作区视图等。文章深入浅出地解释了每个技巧，帮助开发者更高效地使用VS Code。阅读完文章，相信你会更熟练的使用 VSCode 👉 原文链接：10个VSCode 技巧提升你的研发效率 工具推荐更轻量更快的模板引擎 - eta.jsEta.js 是一个轻量级、高性能的嵌入式JavaScript模板引擎，适用于Node.js、Deno和浏览器环境。它使用TypeScript编写，强调优异的性能、配置灵活性和小的捆绑大小。Eta具有零依赖性，压缩后大约3.5KB，并支持Deno、Node和浏览器。它还提供强大的功能，如预编译、部分视图、异步处理和布局支持。与其他模板引擎相比，Eta提供了一些独特的优势： 与EJS相比，Eta更轻量级，提供更快的模板编译和渲染速度，允许左侧空白控制，提供更灵活的定界符和插件支持，并改进了错误报告机制。 与doT.js相比，Eta简化了自定义定界符的设置，支持异步处理和运行时部分视图，并提供更准确的字符串和多行注释解析。 与Handlebars相比，Eta更加轻量和快速，不需要注册大量助手函数就能执行简单任务，同时Eta的模板作为受信任的代码运行，这意味着它可以执行任何合法的JavaScript表达式。 👉🏻工具官网 更轻量更快的模板引擎 - eta.js Open-Sora： 完全开源的高效复现类Sora视频生成方案Open-Sora项目是一项致力于高效制作高质量视频，并使所有人都能使用其模型、工具和内容的计划。 通过采用开源原则，Open-Sora 不仅实现了先进视频生成技术的低成本普及，还提供了一个精简且用户友好的方案，简化了视频制作的复杂性。 通过 Open-Sora，我们希望更多开发者一起探索内容创作领域的创新、创造和包容。 👉🏻工具官网 Open-Sora： 完全开源的高效复现类Sora视频生成方案 行业新闻李彦宏“程序员将不再存在”言论被周鸿祎驳斥，网友怒怼：先把百度程序员都开除了！在 3 月 9 日央视的《对话》·开年说节目上，百度创始人、董事长兼 CEO 李彦宏表示，基本上以后不会存在“程序员”这种职业了，因为只要会说话，人人都会具备程序员的能力。“未来的编程语言只会剩下两种，一种叫做英文，一种叫做中文，这也是目前世界上人工智能技术最领先的两个语言。”对此网友怒怼：先把百度程序员都开除了！ 👉🏻 原文地址 全球首个AI程序员诞生 Devin全球首位AI软件工程师Devin诞生了，它掌握全栈技能，云端部署、底层代码、改bug、训练和微调AI模型都不在话下。最可怕的是，它完全不怕996，老黄的预言是彻底成真了！ 👉🏻原文地址 全球首个AI程序员诞生，码农饭碗一夜被砸，10块IOI金牌华人团队震撼打造，996写代码训练模型","link":"/2024/03/22/2024/0x20240322/"},{"title":"前端早读精选 - 第三期","text":"总结系列2023 JS受欢迎库盘点 2023 年度盘点，根据比较过去12个月在GitHub上添加的 Star 数量与对 Best of JS 的项目进行分析，得到一个与 web 平台相关的最佳项目列表。 总体最流行项目排行其中 shadcn/ui最让笔者意外，接下来让我看看一款复制粘贴的一组 UI 组件如何席卷全球！ shadcn/ui 是一款基于 React 的 UI 组件库，通过 TailwindCSS 定制样式。其建立在 Radix之上，与其它传统 UI 组件库不同的是，它不是一个 NPM 包，你可以通过 cli 的命令将代码集成到你本地，或者直接从官网将对应的源码粘贴到你本地。在前两期我们介绍过的 v0.dev，其生成的 UI组件代码就使用了 shadcn/ui。简单看一下通过 cli 安装到本地的代码，对于有一定业务定制诉求的需求来说，基于源码维度的修改不要太方便！ 另外列举几款笔者比较感兴趣的项目介绍： **tldraw**：一个好用的画图工具，上榜的 excalidraw也是同类型的画图工具。在一些负责的系统架构图上，drawio 也是一个不错的选择。 **tauri**：使用 Web 前端技术构建更小、更快、更安全的桌面应用程序。相较于 Electtron ，tauri 的脚手架要丰富很多，能够快速搭建一个小 demo 上手，这对新手玩家来说很重要。下面简单对比一下二者的优缺点： 特征/优缺点 Tauri Electron 使用的技术 使用 Rust 和 Web 技术（HTML/CSS/JS/TS） 使用 JavaScript/TypeScript、HTML 和 CSS 二进制文件大小 相对较小 相对较大 启动时间 较短 较长 系统资源占用 相对较少 相对较多 跨平台支持 是，支持 Windows、macOS 和 Linux 是，支持 Windows、macOS 和 Linux 安全性 考虑较多，使用 WebAssembly 和沙盒技术 较低，共享主进程可能存在潜在的安全风险 自定义窗口和功能 是，提供灵活的 API 是，提供灵活的 API 社区和生态系统 相对较小但活跃 相对较大且成熟 开发语言 使用 Rust（底层）和 Web 技术 使用 JavaScript/TypeScript、HTML 和 CSS 学习曲线 相对较陡，需要了解 Rust 相对较缓，使用 Web 技术更为常见 适用场景 适用于对二进制大小、启动时间和系统资源占用要求较高的项目 适用于较大型应用，对二进制大小和启动时间要求相对较宽松 前端最受欢迎项目大部分项目都是大家日程接触过或正在使用的项目，这里介绍一个号称能让让 react 速度提升 70%的项目 – Million。 Million 是一个轻量级、快速的虚拟 DOM 库，它使用编译器来预先计算用户界面。这使得 Million 的性能比传统的虚拟 DOM 库更高，并且可以减少 JavaScript 包的大小。并且 Million 可以作为 React-DOM 的替代品，来提升 react 性能。 Million 的优势包括： 性能：Million 的性能比传统的虚拟 DOM 库高出 133% 到 300%。 包大小：Million 的包大小只有 1KB，比传统的虚拟 DOM 库小得多。 易用性：Million 的 API 与 React 类似，可以快速上手。更多关于 Million的介绍，可以点击查看 最受欢迎的后端/全栈项目 tRPC 在上周的周刊中已经介绍了，这里再对另外一款笔者比较感兴趣的项目–Astro 项目做一个简单介绍。提到 Astro 就不得不提其群岛的前端设计架构。“Astro 群岛“指的是静态 HTML 中的交互性的 UI 组件。一个页面上可以有多个岛屿，并且每个岛屿都被独立呈现。你可以将它们想象成在一片由静态（不可交互）的 HTML 页面中的动态岛屿。在 Astro 中，“岛屿”指的是页面上的任何交互式 UI 组件。你可以将岛屿想象成在一片由静态、轻量级、服务器渲染的 HTML 所构成的海洋中所漂浮的交互式小部件。岛屿始终独立于页面上的其他岛屿运行，且一个页面上可以存在多个岛屿。尽管岛屿在不同的组件上下文中运行，它们仍然可以共享状态并相互通信。这种灵活性使得 Astro 能够支持多个 UI 框架，如 React、Preact、Svelte、Vue 和 SolidJS。由于它们是独立的，你甚至可以在每个页面上混合使用多种框架。详细的群岛架构设计文档请看：群岛架构：Jason Miller 更多细分领域榜单，请点击查看。 文章推荐what-is-htmx htmx 在2020年 11 月正式发布 1.0.0 版本。它可以用超文本(标记)的简单和强大来创建尖端的用户界面。它提供了使用属性直接在HTML中访问AJAX、CSS过渡、WebSockets和服务器发送事件的功能。对于开发人员来说，这已经成为游戏规则的改变者，因为它使他们能够仅从标记中实现交互性(JavaScript提供的)。 引用 Jamie Birch 在前端2024趋势预测 UI框架板块对其的评价 In the background, though, is the refreshingly measured advocation of HTMX, which, although it may be the worst framework, is becoming increasingly hard to ignore in this age of complex build tooling. react-server-component 对于最近网上讨论比较凶的 react-server-component的观点输出。本文评估了React Server Components在Next.js中的应用。作者认为React Server Components为React引入了服务器端能力，强调了其在用户体验和开发者体验方面的一些优点和局限性。文章中提到对批评的考虑以及作者对React演进的回顾。作者指出React Server Components的一些新特性，并讨论了其中的一些优势和不足之处，包括在处理高级用例时可能变得繁琐的问题。此外，文章还提及了与Next.js App Router相关的问题，包括对内置fetch API的修改和增加的复杂性，以及JavaScript bundle的大小问题。最后，作者总结了对React和Next.js未来发展方向的一些观点，认为解决现有的客户端问题同样重要。 工具推荐vx.dev Vercel 的 v0.dev 可以通过输入需求，直接生成网站。这里是它的一个开源仿制品，通过逆向工程进行模仿，详见介绍文章。 Github Copilot Chat 作者发现 Github Copilot Chat 的底层是调用 ChatGPT 接口，因此做了这个工具。可以实现将 Github Copilot 转换为 ChatGPT。具体实现原理 杂七杂八nostalgist 一个在浏览器中运行怀旧游戏主机模拟器的 JavaScript 库，比如运行任天堂FC 模拟器、世嘉 MD 模拟器、街机模拟器等等。 结语本文全面盘点了2023年JavaScript库热门趋势，通过GitHub Star和Best of JS项目分析，列举了web平台相关的最佳项目，特别关注了shadcn/ui等。此外，作者还介绍了其他有趣项目，包括tldraw、tauri、Million等。在后端/全栈方面，文章关注了Astro。除了库的盘点，还推荐了一些工具如Vercel的v0.dev、Github Copilot Chat、nostalgist等。这些工具包括网站生成、代码生成和怀旧游戏模拟器等","link":"/2024/01/12/2024/0x20240112/"},{"title":"前端早读精选 - React 官方跨端方案 - react-strict-dom、AI手机颠覆传统APP，前端开发又要变？","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：本期为大家带来浏览器原理解析、 通过 Web Component 融合多款前端框架、 浏览器渲染流水线解析与网页动画性能优化、 React 官方的跨端方案 react-strict-dom、 Css 文档对齐小技巧 – hanging-punctuation； **工具推荐**：AI 编程伴侣 – GPT PILOT、多平台支持的截图、录屏、录音、录像、录制(动图)gif 工具 – pear-rec **行业新闻**：AI 手机来了，App 将消亡，前端开发范式变了？ 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐[推荐 🔥]浏览器原理解析chrome 团队分享的浏览器原理解析。系列一共有 4 个部分，第一部分主要是深入探讨 Chrome 浏览器，从高级架构到渲染流水线的细节。 第二部分阐述了，Chrome 的内部运作方式，从在浏览器中输入网址开始，到浏览器从互联网提取数据并显示网页，整个过程经历了什么。第三部分将详细阐述渲染程序进程是如何渲染。第四部分介绍 Chrome 如何处理用于显示网站的代码。相信大家看完对浏览器的工作原理会有更深的理解。 👉🏻原文链接：浏览器原理解析 通过 Web Component 融合多款前端框架 [英]作者通过在一个待办事项应用中融合使用了React、Vue、Solid和Svelte四个不同的JavaScript框架，展示了Web组件的互操作性。作者创建了自定义的Web组件，允许每个框架的组件独立运作且相互集成，实现了在单一应用中同时使用多个框架的目标。这种方法展现了Web组件能够跨框架工作的能力，有助于避免开发过程中对某个特定JavaScript框架的依赖，从而提高了代码的复用性和应用的灵活性。代码地址 👉🏻原文链接：Web Components Eliminate JavaScript Framework Lock-in 浏览器渲染流水线解析与网页动画性能优化文章全面阐述了浏览器渲染流水线，从Blink引擎处理HTML、CSS到Layer Compositor和Display Compositor的图层管理和最终输出。文章探讨了多进程架构，解释了每个进程在渲染中的作用，并详细讨论了帧的生成及其对动画流畅性的重要性。同时，文章也关注了移动设备上的渲染性能，特别是JavaScript绑定和光栅化的影响，并展望了GPU光栅化等技术对未来渲染流水线的潜在改进。 👉🏻原文链接：浏览器渲染流水线解析与网页动画性能优化 react-strict-dom [英]Meta 官方推出的React Native Web 的继任者，它将允许我们使用一个代码库构建通用应用程序，并使用平台的 API 在多个目标上交付，而不会出现任何妥协或性能问题。react-strict-dom 采用了与 React Native for Web 相反的方法，它利用 Web API 来渲染组件。为此，它添加了两个小的 polyfill，负责将其 API 翻译为 react-native 和 react-dom 两个环境下的原生实现。 👉🏻原文链接：react-strict-dom CSS 中的hanging-punctuation属性[英]文章讨论了CSS中的hanging-punctuation属性，该属性通过使标点符号悬挂在文本对齐边缘之外来增强文本可读性，实现更整洁的文本对齐。这个属性对于改善网页设计中的文本布局非常有用，可以使文本跨行对齐更加美观。文章还探讨了如何使用这个属性，它可以采用的不同值，以及它对文本布局的视觉影响。 👉🏻原文链接：CSS 中的hanging-punctuation属性 工具推荐GPT PILOTGPT Pilot 是 Pythagora VS Code 扩展的核心技术，旨在提供第一个真正的 AI 开发者伴侣。它不仅仅是一个自动补全或者 PR 消息的助手，而是一个真正的 AI 开发者，可以编写完整的功能，调试它们，与您讨论问题，请求审查等。 pear-recpear-rec(梨子 rec) 的跨平台是基于 electronjs,前端是基于 reactjs,截图、录屏、录音、录像、录制(动图)gif 等功能是基于 webrtc 和 webcodecs 的一个项目。 行业新闻AI 手机来了，App 将消亡，前端开发范式变了！自打三星推出首款AI手机三星Galaxy S24后，AI 手机的概念越来越火🔥。在上个月的 MWC 2024 上，德国电信联合高通、Brain.ai 推出了一款突破性创新的概念 AI 手机 T phone。与传统智能手机不同，这款手机主打一个“无 App”，它清除了屏幕上的密密麻麻的 App 图标，只留有一个按钮用来激活手机里的 AI 助手，让用户通过类似 ChatGPT 的操作界面来交互。 这款手机的长期愿景是消灭 App，并干掉 App Store，德国电信 CEO 蒂姆·霍特格斯（Tim Hoettges）在大会上给出了疯狂的预测：“手机 App 将在未来五到十年内消亡” 各位读者，你怎么看AI手机？","link":"/2024/03/29/2024/0x20240329/"},{"title":"前端早读精选 - 可视化 Promise 执行解析，彻底弄懂 Promise、67种浏览器调试技巧，不再无脑console","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：本期为大家带来通过可视化的方式解析Promise的执行过程、67 种浏览器调试技巧，不再是无脑console、Node 与 Bun 一个简单的 WebSocket 性能对比、最受欢迎的 CSS 框架排名 **工具推荐**：用 React 的编码模式去写threeJS – react-three-fiber、写一段文案就能快速生成视频的AI工具 – MoneyPrinterTurbo、利用 Obsidian 插件，也能用上大模型！ **行业新闻**：国内首个AI程序员入职阿里云 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐可视化 Promise 执行文章讲述了JavaScript中Promise的执行机制，解释了new Promise构造函数如何创建Promise，以及Promise在异步任务中的角色。它详细说明了Promise的解决（resolve）和拒绝（reject）过程，以及微任务队列（Microtask Queue）在事件循环中的作用，展示了Promise如何实现非阻塞操作并改善代码的可读性和可维护性。 👉原文链接👉🏻：可视化 Promise 执行 你应该知道的 67 种浏览器调试技巧这篇文章是关于浏览器调试技巧的深入指南，提供了一系列高级方法以帮助开发者更有效地使用开发者工具进行调试。内容包括利用条件断点、监控调用堆栈、动态更改代码行为以及利用浏览器性能分析工具。作者详细解释了如何通过这些技巧查找和解决代码问题，以及如何优化代码性能，使读者能够在调试过程中更加高效和精确。具体技巧如设置智能断点、修改函数运行时行为和性能测试等都有详尽讨论。 👉原文链接👉🏻： 你应该知道的 67 种浏览器调试技巧 Node 与 Bun 一个简单的 WebSocket 性能对比文章介绍了使用JavaScript进行的一个简单WebSocket基准测试，比较了Node.js和Bun两个运行时环境。测试结果显示，在使用WebSocket时，Bun比Node.js快约40%，当切换到专门为Bun编写的JavaScript代码时，Bun的速度是Node.js的两倍。文章强调，这个基准测试旨在测量延迟（即消息往返的时间），而非同时支持的请求数量。 👉原文链接👉🏻：Node 与 Bun 一个简单的 WebSocket 性能对比 The Best CSS Frameworks按 github star 数量排序，40款最受欢迎的 CSS 框架。 Bootstrap 依然强劲！ 工具推荐react-three-fiber一款用 react 的开发方式开发 threeJS。一切在 Threejs 中有效的东西都能使用 React 的编码方式实现。并且得益于 React 的调度能力，它在规模上表现优于 Threejs。通过 JSX 的形式标示 threeJS，实际的转换过程&lt;mesh /&gt; 会动态转换成 new THREE.Mesh()。因此 threejs 版本添加、删除或更改功能，它将立即可用。 MoneyPrinterTurbo利用AI大模型，一键生成高清短视频。只需提供一个视频 主题 或 关键词 ，就可以全自动生成视频文案、视频素材、视频字幕、视频背景音乐，然后合成一个高清的短视频。 给你的 Obsidian 插上 AI 大模型引擎copilot for obsidian的插件和openrouter.ai的AI API，让你的 obsidian 上就能直接使用各种大模型 行业新闻国内首个AI程序员入职阿里云阿里云首个AI程序员“通义灵码”（工号AI001）的入职阿里云啦！这个AI程序员具有编写代码、调试和优化的能力，可以减轻人类程序员的工作量。它能理解和编写超过200种编程语言，其代码续写、查错和优化能力令人印象深刻。 大家怎么看 AI 程序员？","link":"/2024/04/12/2024/0x20240412/"},{"title":"前端早读精选 - 从0到1实现响应式框架、轻松实现小红书内容爬取工具、prettier 性能大幅提升背后的优化动作","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：本期为大家带来对于 React 框架探讨的《因为React，你遗忘或从未了解过的事物》，从0到1创建一款响应式框架，通过这种方式来学习现代化框架的原理、prettier 深度优化背后的事情、css 小技巧，通过css 给两个元素间画连接线 **工具推荐**：好用的爬虫工具，支持现有主流内容网站–MediaCrawler、强大的数据库实体关系（DBER）在线编辑器–drawdb、AI画图 prompt 词参考 – prompt-marketplace、无需代码即可完成对数据库管理的应用生成工具 – dashpress **行业新闻**：主流框架的 Signals 被纳入 JavaScript 标准提案了、 Vision Pro 版淘宝，用户可以进行何种交互！ 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐因为React，你遗忘或从未了解过的事物这篇文章探讨了React作为一个前端框架已经不再是最佳选择的理由，并指出了其设计和技术上的局限性。React是为了解决特定大型组织的问题而设计的，但随着时间的推移，它的架构决策逐渐成为了迭代的障碍。其次，React强化了一个观念，即需要为特定框架定制开发包和库，这限制了开发者利用广泛的JavaScript库的潜力。在性能、代码简洁性和灵活性方面，React 与一些现代前端框架存在一定的差距。特别是在状态管理和组件生命周期的处理上，React的规则和复杂性导致它与通用Web平台的兼容性较差。React 的 Hooks 虽然在引入时革新了状态管理和逻辑复用的方式，但在 React在渲染优化方面需要频繁的微管理，如对useMemo和useCallback的复杂区分和useEffect依赖数组的精细控制，而这些在其他框架中已被更智能的自动处理所取代。 👉原文链接👉🏻： Things you forgot (or never knew) because of React 通过 DIY 来学习现代 JavaScript 框架的工作方式这篇文章详细讲述了如何一步步基于响应式（reactivity）来进行DOM更新的设计思路来构建一个现代的JavaScript框架。首先，使用Proxy对象创建响应式系统来监控状态变化。然后，通过将渲染函数绑定到状态变化上，实现当状态更新时自动重新渲染UI。此外，通过使用&lt;template&gt;标签和DOM克隆技术优化DOM操作，减少性能消耗。最后，确保每次状态变化都能触发正确的界面更新，完成响应式框架的构建。 👉原文链接👉🏻： Let’s learn how modern JavaScript frameworks work by building one Prettier 性能深度优化作者Fabio Spampinato从零开始重写了CLI，以便从性能角度考虑进行优化。文件查找优化主要通过并行处理和预先过滤非目标文件来实现，这样可以缩短文件扫描的总体时间。至于配置文件解析的优化，则包括了缓存已解析的配置以减少重复计算，以及优化配置继承逻辑以提高处理速度。通过这些策略，Prettier的CLI 能更快地响应用户命令，特别是在大型项目中，这些优化带来了显著的性能提升。 👉原文链接👉🏻： Prettier’s CLI: A Performance Deep Dive 使用 CSS 绘制连接元素的线条这篇文章探讨了如何使用CSS锚点定位（CSS Anchor Positioning）来连接网页元素。作者通过实例展示了如何用CSS而非大量JavaScript来连接不同列中的单词，形成有趣的词组。具体方法包括使用CSS的anchor-name和anchor()函数定位连接线，以及利用CSS网格布局和数据属性来管理元素。这种方法减少了JavaScript的计算需求，将更多的布局责任交给了浏览器。 注意：需要使用 Chrome Canary 来查看演示效果 👉原文链接👉🏻： Drawing a Line to Connect Elements with CSS Anchor Positioning 工具推荐MediaCrawler利用 playwright 搭桥，保留登录成功后的上下文浏览器环境，通过执行JS表达式获取一些加密参数，从而爬取对应网站的数据。目前能抓取小红书、抖音、快手、B站、微博的视频、图片、评论、点赞、转发等信息。 附： 该项目使用了 playwright，对 playwright 感兴趣的同学，可以查看playwright 使用指南 playwright 安装第二步需要下载 Chromium 内核文件,这个过程比较慢。可以先手动下载好这些文件,然后直接复制到对应的目录,跳过第二步的下载过程。能够加快安装速度，避免失败。不同系统对应的安装路径如下: Windows: %USERPROFILE%\\AppData\\Local\\ms-playwright macOS: ~/Library/Caches/ms-playwright Linux: ~/.cache/ms-playwright drawdb这个开源项目是一个免费、简单、强大的数据库实体关系（DBER）在线编辑器，无需注册即可直接在浏览器中使用。它提供了直观、可视化的操作界面，用户通过点击即可构建数据库表和导出建表语句，还可以导入建表语句，实现可视化编辑、错误检查等。支持 MySQL、PostgreSQL、SQLite、MariaDB、SQL Server 共 5 种常用的关系数据库。 dashpress无需编写一行代码即可生成强大的管理应用程序 prompt-marketplace适用于多个平台的免费AI图像提示词。每天更新提示 行业新闻JavaScript 原生 Signals 标准提案关于 Signals 标准提案，该提案与 Promises/A+类似，侧重于使 JavaScript 生态系统保持一致。如果这种对齐成功，那么一个标准可能会出现，该标准基于这种经验。几位框架作者正在此处合作共同制定一个可能支持其响应式的通用模型。当前草案是基于 Angular、Bubble、Ember、FAST、MobX、Preact、Qwik、RxJS、Solid、Starbeam、Svelte、Vue、Wiz 等作者/维护者的设计输入… 用 Vision Pro 逛了一下午淘宝，我发现了一种很新的网购方式未来的网购会是怎样的？足不出户，就能看见商品的 3D 展示；不仅能把产品放大看细节，还能还原 1:1 的真实比例，放在房间的任何角落看看尺寸是否合适；甚至能把毛坯房用虚拟家具堆满，在装修之前就能确定新房的装修风格。 附：作为一个前端开发者，对于这种新的交互模式很感兴趣。这里给大家推荐一款 RN 的 Vision Pro 开发框架 – react-native-visionos那么问题来了，环境搭好了，请问 Vision Pro 去哪里领呀？","link":"/2024/04/19/2024/0x20240419/"},{"title":"前端早读精选 - React 19 Beat 正式发布 NPM、Qwik 与 NextJS 大比拼","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：React 19 Beta 发布 NPM 了！为大家带来最新版本的简要介绍；Qwik 与 NextJS 多维度对比；Chrome 崩溃了，我是如何一步步找到崩溃原因的；仅用 CSS，如何使用鼠标hover，3D礼物盒打开效果 **工具推荐**：基于 LaTeX 的简历制作工具 – PPResume，轻松创建专业且视觉吸引力强的简历；通过有趣的视觉方式展示你一生的重要数据统计 – life-stats；利用 Chrome 的 DevTool 分析 NodeJS 性能 **行业新闻**：如果你还在使低版本 JQuery，那可能有潜在的安全风险，JQuery 与 OpenJS 共同推出，JQuery 升级指南。 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐React 19 BetaReact 19 Beta 现已在 npm 上发布！以下是 react 新功能简单总结： 引入的一些新hooks特别关注于改进客户端与服务器之间的数据交互和状态管理： useFormStatus：这个hook用于跟踪表单的提交状态。当表单数据正在被处理时（例如，正在发送到服务器），这个hook可以提供实时的状态更新，帮助开发者实现更好的用户交互反馈。 useActionState：与useFormStatus类似，useActionState提供了一种方式来管理和跟踪通过Actions提交的数据的状态。这个hook可以用来获取异步操作（如服务器上的数据处理）的当前状态和结果，使开发者能够根据这些状态来调整UI反馈。 useOptimistic：这个hook用于实现乐观更新逻辑。在数据被最终确认之前，它允许应用暂时显示预期的最终状态。如果后续操作失败或有错误发生，useOptimistic会帮助自动回滚到操作前的状态，从而确保数据的一致性和用户界面的准确反映。 新的API use：这是一个用于在渲染过程中读取资源的新API。它允许组件在等待异步数据如Promise解析时暂停渲染。React 将在数据准备好后继续渲染组件。 Server Components 和 Server Actions：React 19稳定版包含了之前Canary频道中的Server Components特性。这些组件可以在构建时或每次请求时在服务器上运行，优化了客户端加载性能。Server Actions则允许客户端组件调用在服务器上执行的异步函数。 改进的ref作为prop的用法：React 19开始，你可以将ref直接作为函数组件的prop使用，这消除了forwardRef的需求。此外，React现在支持在ref回调中返回清理函数，用于在组件卸载时执行清理操作。 Hydration错误的改进报告：React 19改进了hydration错误的处理，当服务器渲染的HTML与客户端渲染不匹配时，React将提供详细的差异报告，帮助开发者快速定位问题。 使用&lt;Context&gt;作为provider：现在可以使用&lt;Context&gt;直接作为provider，而不是&lt;Context.Provider&gt;，简化了上下文的使用。 useDeferredValue新增initialValue参数：这允许开发者在组件的首次渲染时提供一个初始值，这对于性能优化尤为重要。 移除和弃用的功能：包括移除了一些老旧或较少使用的API如ReactDOM.findDOMNode、createFactory，以及对react-test-renderer的弃用，推荐使用更现代的测试库如React Testing Library。 👉🏻原文链接： React 19 Beta Qwik vs. Next.js：你的下一个Web项目应该选哪个框架？文章对 Qwik和Next.js在多个维度进行比较，为什么 Qwik 会作为作者的首选框架。Qwik通过其优化的服务器端渲染和状态管理机制（如使用signals），提供了更快的启动时间和更高的性能，特别是在减少hydration需求和改善加载时间方面表现出色。此外，Qwik通过支持如qwikify$函数，允许在Qwik应用中整合和延迟加载React组件，虽然不是基于React，但能有效利用React生态系统。相对而言，Next.js作为基于React的框架，与React生态系统的整合更为天然和深入，特别适合React开发者。它在缓存控制和灵活的页面加载策略（如支持SSR和CSR）方面具有优势。在开发体验方面，Qwik利用Vite作为开发服务器，提供快速的响应和热模块替换功能，而Next.js虽然也提供快速构建，但在某些开发方面Qwik可能更有优势。 👉🏻原文链接：Qwik vs. Next.js：你的下一个Web项目应该选哪个框架？ 如何找到Chrome的Crash原因？作者在分析Chrome崩溃的问题时采取了一系列有条理的步骤。首先，通过修正预测的内存泄露尝试解决问题。当问题未得到解决时，通过配置和使用Chrome的内建转储工具生成这些文件。接着，作者利用Breakpad工具对这些崩溃转储文件进行解码和分析，这一过程需要编译Breakpad工具，并下载与Chrome版本相对应的符号文件。 👉🏻原文链接： 如何找到Chrome的Crash原因？ 在 CSS 中滑动 3D 图像框架这篇文章介绍了如何使用CSS技术在不添加HTML元素的情况下，为图片创建滑动3D效果。作者Temani Afif通过巧妙利用CSS属性，如box-shadow、clip-path和object-fit等，制作了一个看似可以滑动的图片框架，这种效果使得图片像是在一个盒子中被逐渐揭示出来。此外，文章还探讨了如何在图片上添加边框，调整padding，以及如何通过增加深度和使用渐变效果增强3D视觉效果。 👉🏻原文链接： 在 CSS 中滑动 3D 图像框架 工具推荐简历制作工具–PPResumePPResume是一个基于LaTeX的简历制作工具，旨在帮助用户快速创建专业且视觉吸引力强的简历。该平台提供多种精心设计的模板，并允许高度自定义排版和设计元素，以确保简历的独特性和高质量。简历以PDF格式输出，以保持在所有平台上的格式一致性。目前处于测试阶段，PPResume提供免费服务，但有创建简历的数量限制。 👉🏻工具地址： 简历制作工具–ppresume life-stats通过有趣的视觉方式展示你一生的重要数据统计。用户只需输入自己的出生日期，该网站会计算并展示从出生至今的各类统计数据，如呼吸次数、心跳次数、睡眠时间等。 👉🏻工具地址：life-stats NodeJS 性能分析工具利用 chrome inspect 工具，打开Node 分析工具，支持断言，与性能分析。 👉🏻工具地址：NodeJS 性能分析工具 行业新闻升级 jQuery：努力构建健康的网络jQuery 对 Web 的影响将一直存在。自 2006 年首次推出以来，jQuery 几乎立即成为 Web 开发人员的基本工具。它简化了 JavaScript 编程，使操作 HTML 文档、处理事件、执行动画等变得更加容易。从那时起，它在 Web 标准和浏览器功能的演变中发挥并继续发挥着重要作用。但随着现代 JavaScript 框架的兴起，越来越少的开发人员可能会选择在新项目中使用 jQuery，但全球范围内的使用率仍然非常高。根据 IDC 进行的一项调查结果分析，OpenJS 基金会估计 90%的网站使用 jQuery。其中约三分之一使用的是过时版本。jQuery 团队和 OpenJS 基金会正在努力解决这个问题，通过该指南，引导您完成升级 jQuery 的过程。","link":"/2024/04/29/2024/0x20240429/"},{"title":"前端早读精选 - oclif 工具指南、CSS 处理文档溢出、你应该知道的 HTML Dom 与节点属性差异","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：oclif 一款 cli 框架的使用指南，带你快速搭建一款属于你自己的 CLI 工具、HTML Dom 属性与节点属性之间的区别，以及各大框架是如何处理的、两篇关于 CSS 魔法：1）利用 CSS 实现对文档溢出处理；2）利用 CSS 的 grid 布局绘制出一款乐谱 **工具推荐**：AI 集成工具 – MaxAi.me。一键快速使用各类 AI 工具 **行业新闻**：Bun 1.1 发布、Node V22 版本发布，快来看看它们的新特性吧 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐oclif 工具指南这篇文章是一篇教程，在不使用 oclif 的脚手架的情况下，如何搭建一个使用 oclif 搭建一个命令行工具。文章从设置项目、初始化目录、配置 TypeScript 编译器的步骤，并通过创建和扩展 oclif 的 Command 类来展示如何添加命令、参数和标志 介绍了如何使用 TypeScript 和 oclif 框架从头开始构建一个命令行接口（CLI）应用程序。 附：cli 框架对比 特性/框架 oclif Commander.js Caporal.js 主要优点 强大的插件系统，功能丰富 简单直观，易于上手 参数验证，支持多语言 主要缺点 相对复杂，学习成本较高 子命令处理基础 社区较小，文档支持有限 社区和维护 由 Heroku 和 Salesforce 维护，社区活跃 社区非常活跃，维护良好 社区较小，更新可能不频繁 适用场景 大型、模块化的应用，需要可扩展性 快速开发简单到中等复杂度的 CLI 工具 需要内置参数验证和国际化支持的应用 自动化帮助 支持 支持 支持 性能 较重，不适合轻量级应用 性能良好，适合大多数应用 性能适中 👉🏻原文链接： oclif 工具指南 HTML属性 VS DOM属性详细讲解了HTML属性和DOM属性的区别，这是Web开发中的基本概念，但经常被误解。以下是文章的几个关键点总结： 属性与属性的区别：HTML属性是直接在HTML中定义的，总是字符串形式，而DOM属性是DOM对象模型的一部分，可以是任何类型。属性在HTML标记中可见，但属性通过JavaScript以编程方式访问。 序列化与大小写敏感性：属性可以序列化到HTML中，即它们可以在标记中被看到，并且它们是不区分大小写的。相反，属性不会序列化到HTML中并且是区分大小写的。 Reflection：某些属性在更改时会自动更新其相应的属性，反之亦然。但这并不总是如此，有些属性的更改不会反映到属性上。 验证、类型强制和默认值：属性可以强制执行验证规则和类型，自动将值转换为适当的类型或默认值。例如，如果为&lt;input&gt;元素的类型属性设置了非有效类型，它将恢复为默认的有效类型。 框架和自定义元素：文章还讨论了不同的JavaScript框架如何处理属性和属性之间的区别。例如，React和Vue等框架在将组件渲染为字符串或处理自定义元素时，有特定的处理方式。 Preact 和 VueJS：通常优先将属性设置为DOM属性，除非属性名不是元素的已知属性，这种情况下才设置为HTML属性。在服务器端渲染时，它们倾向于只处理HTML属性。 React：React的默认策略是将大多数属性设置为HTML属性，除非这些属性被预定义为DOM属性。这种方式影响了自定义元素的功能实现，因为它们的属性可能不被识别为DOM属性。 lit-html：要求开发者在设置DOM属性时，在属性名前加上点（.），如.value，以明确区分HTML属性和DOM属性。 👉🏻原文链接： HTML属性 VS DOM属性 纯 CSS 检测文本是否溢出本文介绍了一种通过CSS滚动驱动动画和CSS样式查询实现文本溢出检测的技术方案。首先，使用CSS滚动驱动动画标识容器是否溢出的方法包括在容器内部设置动画，该动画与滚动事件相关联。具体实现方式是通过定义animation-timeline属性来依赖于容器本身的滚动状态，例如使用scroll(self)表示监听容器自身的滚动。当容器滚动时，动画被触发，通过动画中的关键帧更改如颜色等属性，可以视觉上标识出容器是否发生了溢出。 一旦容器被识别为溢出，CSS样式查询（即容器查询）则用于进一步定制不同状态下的样式。例如，可以在检测到容器溢出时，使用@container规则来应用特定的样式变更，这些变更仅在满足特定条件（如文本溢出）时才生效。这种查询可以指定基于容器内部状态的样式，如在CSS中设置变量–trunc，然后在容器查询中检测这个变量的值，如果为真（表示溢出），则可以调整子元素的显示，比如显示“展开”按钮或改变背景色等。 这种结合使用滚动驱动动画和样式查询的方法不仅增加了页面样式的动态响应能力，也使得CSS在处理复杂交互和布局问题时更加强大和灵活。 👉🏻原文链接： 纯 CSS 检测文本是否溢出 使用 CSS 绘制乐谱这篇文章详细介绍了使用CSS Grid来绘制网页上的音乐谱的方法。作者通过将音乐谱的每个部分（如五线谱、小节和音符）视为网格系统中的元素，利用CSS的属性来精确控制这些元素的布局和样式。文章中展示了如何定义CSS类和网格布局，以实现五线谱的横向和纵向对齐，以及如何使用CSS属性来调整音符的位置和大小。 👉🏻原文链接： 使用 CSS 绘制乐谱 工具推荐MaxAi.me可以在任何地方一键使用 AI，由ChatGPT、Claude 3、Gemini 1.5和GPT-4提供支持。您唯一需要的生成式AI扩展 行业新闻Bun 1.1 发布Bun 1.1 版本正式发布了，这是一个重大版本更新，进一步优化了这个高速的 JavaScript 运行时和工具集。以下是这个版本的简单概述: 性能提升：bun install 在 Windows 上的安装速度提升了50%，通过并行化文件复制和链接操作实现更快的性能​ (Bun)​。 新特性和API支持： 对 Date.parse() 函数进行了改进，以兼容 Node.js 的行为，解决了日期解析在不同 JavaScript 引擎间的不一致问题​ (Bun)​。 增加了对递归文件目录读取的支持，并显著提升了 fs.readdir() 的性能，使其比 Node.js 快22倍​ (Bun)​。 Bug修复和稳定性改进： 解决了多个与 Bun Shell、fs.watch、和 bun build –compile 相关的bug，包括修正 bun build –compile 未正确处理输出文件路径的问题​ (Bun)​​ (Bun)​​ (Bun)​。 改善了 Bun 在处理带有无效文件路径的 tarballs 时的行为，现在与 Windows 上的 npm install 行为一致​ (Bun)​。 修复了使用 SvelteKit 时 fetch 方法的错误处理问题，确保正确调用重写的方法和属性​ (Bun)​。 跨平台和模块改进： 提升了 Array#sort 方法的性能，根据不同场景可提升 15% 至 135%​ (Bun)​。 在 Bun for Windows 上修正了退出时重置控制台模式的问题，解决了在命令提示符中使用方向键可能出现的问题​ (Bun)​。 与 Node.js 的兼容性：增强了与 Node.js 的互操作性，包括支持 IPC 消息传递和解决了一些 Node.js 未文档化 API 的问题​ (Bun)​。👉🏻 更多更新日志请看看原文链接：Bun 1.1 发布 NodeJS 22 发布Node V22 版本正式发布了，新版本引入了几项重要的新特性和更新，旨在提高性能、增强安全性，并支持更现代的 JavaScript 功能。以下是这个版本的简单概述： V8 引擎更新：Node.js 22 更新了其 V8 JavaScript 引擎到最新版本，带来了性能改进和对新的 ECMAScript 特性的支持。 性能优化：此版本包括对 Node.js 核心部分的性能优化，例如模块加载和 HTTP 处理。 新的和改进的 API： 引入了对新的 ECMAScript 模块（ESM）加载器的支持，这些加载器现在可以在一个独立的线程中运行，从而避免干扰主线程。 提供了更多控制文件系统访问的功能，包括读写权限的细粒度控制。 强化了对 WebAssembly 和 Web Crypto API 的支持，使 Node.js 在处理网络安全和性能敏感型任务时更为有效。 实验性功能：引入了一些新的实验性功能，如单一可执行应用的支持，这可能在未来版本中成为稳定功能。 安全性增强：包括对特定安全性能的改进，如改进的错误处理和更新的安全协议支持。 👉🏻 更多更新日志请看看原文链接：NodeJS 22 发布","link":"/2024/05/10/2024/0x20240510/"},{"title":"前端早读精选 - React Compiler 终于来了、实时通信技术方案对比、使用 Bun 最佳场景","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **文章推荐**：前后端实时通信的几种方案对比、对比 NodeJS，Bun更适合的几个关键场景、对比 dotenv，Node v20.6 以后的新版本更优雅的处理方式、苦等三年，React Compiler（原来叫 React Forget）终于来了。 **工具推荐**：vspace 浏览器标签管理工具、ElysiaJS 基于 Bun 的服务端框架、DashPlayer 学习英语的好帮手 **行业新闻**：React Conf 2024 都有啥、Google AI 视频方案 Veo 如果觉得有收获，欢迎大家点赞👍🏻订阅 文章推荐ws、sse、polling、webrtc、webtransport 对比这篇文章比较了几种用于实时Web应用的技术，包括长轮询（Long-Polling）、WebSockets、服务器发送事件（SSE）、WebRTC和WebTransport。文章详细介绍了每种技术的工作原理、优缺点和适用场景。长轮询适用于低效率的后备机制，WebSockets适合需要双向通信的场景，SSE适合单向服务器到客户端的实时更新，WebTransport是未来的高效通信技术，而WebRTC主要用于点对点通信。文章还讨论了这些技术在性能、延迟、吞吐量和可扩展性方面的比较。 👉🏻 原文链接：ws、sse、polling、webrtc、webtransport 对比 何时使用 Bun 而不是 NodeJS文章讨论了在某些场景下使用 Bun 代替 Node.js 的优势。Bun 是一种新兴的 JavaScript 运行时，因其卓越的性能和内置功能而受到关注。以下是文章中提到的几个关键场景及其对比 Node.js 的优势： 性能需求高：由于使用 Zig 语言编写，Bun 比 Node.js 更快，启动速度快 4 倍，包管理速度快 25 倍。 需要一体化解决方案：Bun 内置了包管理器、测试工具和打包器，提供统一的开发体验。 模块解析复杂：提供一致的模块解析系统，兼容 CommonJS 和 ES 模块，简化了模块间的互操作性。 需要高效的内置数据库：集成了高性能的 SQLite 驱动，适合作为内部数据库使用。 需要未来可切换到 Node.js 的灵活性：设计为与 Node.js 兼容，便于在需要时切换到 Node.js。 👉🏻原文链接: 何时使用 Bun 而不是 NodeJS 你可能并不需要dotenv在 Node.js 20.6.0版本发布后，Node.js 现在原生支持 .env 文件加载，使开发者不再需要使用外部包如 dotenv 来管理环境变量。通过使用 --env-file 标志可以轻松加载 .env 文件，简化配置过程并提升性能和安全性。 举个🌰：假设有一个名为 config.env 的文件，内容如下： 1`NODE_OPTIONS='--title=&quot;Testing Node v20.6.0&quot;' USER_NAME='John Doe'` 你可以使用以下命令来加载这个文件，config.env文件中的变量将被加载到process.env` 1`node --env-file=config.env index.js` 👉🏻原文链接：你可能并不需要dotenv 苦等三年，React Compiler 终于能用了。使用体验：很爽，但仍有瑕疵React Compiler（原名 React Forget）终于在 React Conf 2024 开源。它通过缓存未变更的组件，解决了 React 中冗余的 re-render 问题，从而提升性能。React Compiler 集成于代码自动编译中，使用时不改变现有开发方式。可以通过react-compiler-healthcheck来对老代码进行检查，判断其兼容性。此外 React Compiler 还支持局部使用，通过配置可以仅针对某些文件夹进行 compiler 优化，适用于多种开发环境（如 Vite、Next.js、Remix、Webpack）。虽然有时会遇到问题，但总体上提升了开发体验和性能，尤其对新项目和初学者更友好。 👉🏻原文链接：苦等三年，React Compiler 终于能用了。使用体验：很爽，但仍有瑕疵 工具推荐vspaceVSpace 是一个在浏览器侧边栏上实现的垂直式的书签和标签页管理器扩展，灵感来源于 Arc 浏览器，目的是在非 Arc 浏览器上（主要是 Chrome）做到更好的的侧边栏体验。 适合人群 对浏览器自带的书签管理功能不满意，想要更好的体验 想要在本身不支持垂直标签页的浏览器上使用垂直标签页 想要在其它 chromium 浏览器上体验类似 Arc 浏览器侧边栏功能 浏览器支持 Chrome 完全支持 Edge 支持，但侧面板无法设置到左侧，因为 Edge 不支持 Arc 不支持，因为 Arc 浏览器本身不支持侧边栏扩展 FireFox 不支持 其它 chromium 浏览器 没有测试，理论上只要支持侧边栏的就支持 👉🏻工具地址：vspace ElysiaJSElysiaJS 是一个优化了高性能和开发者体验的 TypeScript 框架。其主要优点包括： 速度快：比 Express 快21倍，利用 Bun 运行时和动态代码注入。 类型安全：确保端到端的类型安全，自动类型推断。 简洁：代码简洁，轻松处理响应并集成 OpenAPI/Swagger 进行文档化。 生产力高：内置验证和统一类型系统，减少样板代码。 社区和插件：广泛的插件支持和强大的社区。 👉🏻工具地址：ElysiaJS DashPlayer一款专为英语学习打造的视频播放器。DashPlayer 的目标就是方便你观看英文视频。无论你是想泛听，还是想一句句精听，亦或是想要查询生词，DashPlayer 精心打磨的手感让您始终心情愉悦。 双语字幕：支持机器翻译字幕。只展示中文/英文，或者全部隐藏都可以。 按字幕跳转： 重复当前句，或者跳到上一句，怎么跳都可以。 查词查询：鼠标悬停生词可快速查询，不打断学习进程。 可调整界面尺寸： 界面尺寸可调，适应不同屏幕和学习场景。 记录播放位置： 自动记录上次播放位置，方便下次接着学习。 蓝牙遥控操作： 支持蓝牙遥控，让你随时调整音量、跳转视频，学习更轻松！ 夜间模式：内置暗色/亮色主题，适配您的学习环境。 AI 字幕：可以使用 AI 为视频生成字幕。 长视频切分：看一段删一段，没有压力。 视频下载：粘贴视频链接，下载视频。 👉🏻工具地址：DashPlayer 行业新闻📹 react Conf 2024React Conf 2024的主要内容围绕React 19的发布以及React团队当前的一些重点工作,如React编译器和React服务器组件。 要说最近前端圈最热的是什么，那当然是 React Conf 2024 了。快点击视频了解一下吧 google-veoVeo 是 Google DeepMind 开发的先进视频生成模型，能够生成1080p高分辨率、长时长的高质量视频。它支持广泛的电影和视觉风格，准确捕捉提示的细微差别，并提供创意控制。Veo 旨在使视频制作更易于访问，解锁叙事、教育等领域的新可能性。 PS：Google 的视频解决方案的热度远远低于 OpenAI 的 Sora。🤔🤔🤔","link":"/2024/05/24/2024/0x20240524/"},{"title":"前端早读精选 - 如何为你的开源项目编写文档、5 中 node 版本管理方案对比、react-compiler 介绍与使用","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **JS 文章推荐**：利用 JSDoc 为你的开源项目编写文档、5 中 node 版本管理方案对比、react-compiler 基本介绍与项目搭建指南、Dan Abramov 关于React 客户端组件与服务端组件的讨论。**CSS 文章推荐**：利用 CSS 绘制图形全面指南、使用 @property 如何完成复杂 CSS 动画、关于 CSS 新特性采用率低的思考 **工具推荐**：浏览器插件开发框架 – extension、使用GitHub Actions自动化更新GitHub个人资料 如果觉得有收获，欢迎大家点赞👍🏻订阅 JavaScript 文章推荐如何为你的开源项目编写文档文章讨论了利用JSDoc为JavaScript包编写文档的方法。介绍了包括清晰描述功能、为代码添加类型信息、利用JSDoc标签详细说明代码功能，以及包含示例帮助用户理解如何使用。文章还提到了使用deno test --doc保持文档的时效性和准确性，以及通过内部链接增强文档的可导航性。 简要总结，使用JSDoc完善你的README指南，可以按照以下结构化的建议操作： 文档摘要: 使用JSDoc撰写清晰的功能摘要，概述你的包或模块的主要功能。 类型信息: 明确指出所有参数、返回值和变量的类型，以增加文档的可读性和实用性。 详细标签: 利用JSDoc的各种标签（如@param, @return）详细描述函数或方法的行为、参数和输出。 示例代码: 在文档中包含示例代码，并用JSDoc注释详细解释每个示例，帮助用户理解如何使用API。 维护文档: 定期运行deno test --doc来验证示例代码的有效性，并确保文档保持最新。 👉🏻原文链接：如何为你的开源项目编写文档 5个 Node 版本管理工具对比这篇文章讨论了Node.js版本管理工具的重要性，通过比较五种主要工具：NVM、N、FNM、Volta和PNPM。 NVM (Node Version Manager) 优点：最受欢迎，安装简单。 缺点：不支持Windows平台，仅支持POSIX兼容的shell。 N 优点：可以从package.json的”engines”部分自动检测Node版本。 缺点：不支持Windows的原生shell，管理的是全局Node版本。 FNM (Fast Node Manager) 优点：支持跨平台，安装直观，支持自动根据项目内的 .node-version 文件自动切换 Node 版本。 缺点：需要用户进行一些配置才能实现版本自动切换。 Volta 优点：跨平台，无缝的日常使用体验，支持Node和其他工具（如Yarn）版本的动态切换。 1234&quot;volta&quot;: { &quot;node&quot;: &quot;18.17.0&quot;, &quot;yarn&quot;: &quot;1.22.22&quot;} 缺点：较新，社区支持和资源可能比NVM少。 PNPM 优点：支持跨平台，与包管理功能集成。 缺点：本质上是包管理器，只支持全局版本管理，不支持动态版本切换。 👉🏻原文链接：5个 Node 版本管理工具对比 react-compiler 这篇文章介绍了React编译器的基本情况，这是一个新的实验性编译器，旨在自动优化React应用程序。它可以对代码进行自动记忆化处理，减少因输入不变而不必要的更新。编译器也包含一个eslint插件，能在编辑器中实时显示代码分析结果，帮助提高代码质量。文章还讨论了如何安装编译器、如何检查代码的兼容性，以及如何在不同的开发环境中配置使用编译器。 注意：这个编译器目前还处于实验阶段，尚未完全准备好用于生产环境。 👉🏻原文链接：react-compiler 两个 ReactDan Abramov 关于使用 React 构建用户界面（UI）时，分别基于客户端和服务器端的数据处理，组件应该在客户端还是服务端运行的问题。在客户端，UI的生成依赖于本地状态（例如交互式组件如计数器），而在服务器端，UI的生成则依赖于服务器数据（如预览卡片显示博客帖子的字数）。作者指出，这两种方法各有优势，但通常看起来无法兼容。文章的核心思想是探索一种能够结合这两种方法的 React使用方式，以充分发挥其在不同环境中的优势。 👉🏻原文链接：两个 React CSS 文章推荐CSS 绘制图形全方位指南这篇文章是关于如何使用CSS创建各种形状的现代指南。作者Temani Afif详细介绍了利用CSS的clip-path和polygon()功能来制作常见的CSS形状，如六边形、八边形和星形等。文章强调了避免使用过时的CSS技巧和“魔术数字”，而是利用现代CSS技术来创建可重用且易于理解的代码。此外，还提供了一些技巧和方法，帮助开发者理解和创建自定义的CSS形状，而不仅仅是复制粘贴代码。以下是文章中几个图形示例： 三角形：通过设定三个顶点的坐标，使用polygon()函数创建。 1clip-path: polygon(50% 0%, 0% 100%, 100% 100%); 心形：利用clip-path结合多个曲线和直线段生成心形。 1clip-path: path('M50 0 Q100 50 50 100 Q0 50 50 0'); 波浪形：通过重复的正弦曲线路径，使用clip-path生成动态的波浪形状。 1clip-path: ellipse(50% 25% at 50% 50%); 👉🏻原文链接：CSS 绘制图形全方位指南 有时候你需要一个自定义@property 而不是 CSS 变量文章重点探讨了CSS中@property的特点，强调其在复杂动画和响应式设计中的优势。与CSS变量主要用于值的存储和复用不同，@property允许开发者定义属性的类型、初始值以及是否继承，支持属性值的动态插值。这使得@property在实现平滑的颜色渐变、尺寸变化等动画效果时，能提供更高的控制精度和视觉连贯性。通过具体示例，文章展示了@property在前端开发中的实用性和灵活性。 笔者附：在CSS中，使用@property与CSS变量有显著区别。CSS变量用于存储可复用的值，主要用于简化和统一样式表中的常量。而@property则提供了定义更复杂属性的能力，比如可以设置类型、初始值以及继承性，使得动态改变属性（如动画中的颜色、尺寸变化等）更为流畅和自然。@property允许属性在变化过程中进行计算和插值，提高了动画和响应式设计的灵活性和效果。但 @property 的兼容性存在一定的问题，详细API信息与兼容性信息查看：MDN 👉🏻原文链接：有时候你需要一个自定义@property 而不是 CSS 变量 old-dogs-new-css-tricks文章探讨了CSS新功能的低采纳率和原因，特别强调了开发者的习惯性思维和技术借口。讨论了一些最新的CSS特性如容器查询、样式查询、CSS层次结构等，并指出这些功能虽然支持良好，但实际应用仍较少。建议通过渐进增强的方式和重新思考已有的编码模式来更好地利用这些新特性，以解决具体的UI问题和改进代码结构。还强调了实践和示例的重要性，以及逐步适应新技术的方法。 笔者附：关于CSS的应用逐渐被忽视，尽管前端开发的基础仍旧是HTML、CSS和JavaScript。如今，大多数人将主要精力放在JavaScript上，而忽略了CSS和HTML的进展。自从我开始编写“早读精选”系列，阅读了许多关于CSS的精彩文章后，深感现在是时候重新审视CSS了。相信我，当你重新重新了解新时代的CSS后，你会看到一个全新的前端世界。 工具推荐extensionExtension 是一个即插即用、零配置、跨浏览器扩展开发工具，内置支持 TypeScript、WebAssembly、React 和现代 JavaScript。开发便捷，使用脚手架（sh npx extension create my-extension ）初始化好工程后，仅需运行npm run dev 即可实现预览，开放你的扩展工具 👉🏻原文链接：extension 如何将我的 github 个人资料变为动态化文章介绍了如何使用GitHub Actions自动化更新GitHub个人资料的README文件，包括博客文章和GitHub统计数据。介绍了两个可以动态生成统计数据的库：github-readme-stats和metrics。还展示了如何通过Python脚本从博客自动抓取最新文章来更新README的方法，并通过代码示例详细解释了整个设置过程。 👉🏻原文链接：如何将我的 github 个人资料变为动态化","link":"/2024/06/05/2024/0x20240605/"},{"title":"前端早读精选 - 你应该知道的 10 NodeJS 新功能、React 19 差点拖慢了整个互联网？","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **JS 文章推荐**：NodeJS 的 10 个新功能、React 19 Suspense 行为变更带来的性能问题、Dom 深度对页面性能影响、HTTP 3.0 QUIC 协议是如何在保障安全的基础上提高速度的 **HTML &amp; CSS 文章推荐**：HTML 2023 调研报告、CSS 技巧：使用 css 完成布局模板、利用 CSS 完成基于时间的动画、利用 CSS 实现倒计时。 **工具推荐**：一款在您的笔记本电脑上完全离线运行AI工具、文字转语音在线版。 如果觉得有收获，欢迎大家点赞👍🏻订阅 JavaScript 文章推荐2024 年开始使用的 10 个现代 Node.js 功能Node.js中一些较新的功能和实验性特性。包括了如何使用Node.js进行测试的相关命令，以及如何利用--experimental-test-coverage生成测试覆盖率报告的方法。文章还探讨了Corepack工具的用途，这是一个实验性功能，用于统一和管理不同版本的包管理器，如Yarn和npm，确保项目的一致性。此外，文章也介绍了Node.js在处理环境变量方面的新功能，例如通过node --env-file来指定环境变量文件。最后，还涉及了一些新的安全性和性能优化特性，如改进的文件系统访问权限和支持import.meta以及Promise的相关优化。 脑图版本： 👉🏻原文链接：2024 年开始使用的 10 个现代 Node.js 功能 React 19 差点拖慢整个互联网！核心团队紧急叫停React 19版本中引入的Suspense行为变更，从并行数据获取改为瀑布式数据获取，引起了社区广泛关注和讨论。这一变更虽意在优化性能，但实际上增加了数据加载时间，特别是在多组件场景下，显著影响了应用性能。 改动前 改动后 👉🏻原文链接：React 19 差点拖慢整个互联网！核心团队紧急叫停 你的 Dom 有多深探讨了DOM深度对网页性能的影响。作者通过实验发现，虽然现代浏览器可以有效处理深层次和复杂的DOM树，但DOM深度增加会显著降低性能，特别是当与样式重新计算结合时。这主要是因为访问深层嵌套元素需要更多操作，从而导致处理耗时增加。 👉🏻原文链接：你的 Dom 有多深 QUIC 是如何取代 TCP 以提高速度和安全性的？文章主要探讨了QUIC协议如何克服TCP存在的问题，并进一步优化了基于TCP的传输方式，特别是在构建更现代化和高效的网络应用方面。QUIC通过结合UDP的高效传输特性并加入TCP的可靠性特点，提供了一种更适合当前网络需求的解决方案。下面的表格将根据文章内容，对TCP、UDP和QUIC的特点、解决的问题以及优缺点进行结构化展示： 协议 特点 解决的问题 优点 缺点 TCP 连接导向、可靠传输 数据可靠性和顺序性问题 可靠性高、保证数据顺序、广泛使用 三次握手延迟、头阻塞问题、效率低于UDP UDP 无连接、传输快、开销小 高效传输需求 开销小、适合实时应用（如视频和音频流）、传输速度快 不保证数据可靠性、不适用于需要高可靠性的应用 QUIC 结合TCP和UDP的特点，基于UDP，实现可靠性、多路复用、快速握手 TCP的延迟和队头阻塞问题，UDP的可靠性问题 握手延迟低、解决了队头阻塞、支持连接迁移、增强安全性 相对较新，普及和支持率还在增长中 👉🏻原文链接：QUIC 是如何取代 TCP 以提高速度和安全性的？ HTML &amp;&amp; CSS 文章推荐HTML 2023一份HTML 调查报告。在 JavaScript 统治 Web、CSS 年年获得新功能的同时，HTML 似乎心甘情愿地保持沉默，把舞台中心让给它的年轻兄弟姐妹。毕竟，一旦 你掌握了 &lt;div&gt; 和 &lt;h&gt;1 到 6，还有什么值得了解的呢？ 其实，还是有很多东西值得探索！调查报告邀请了 Lea Verou 来发挥她对 Web 平台的深厚知识，设计了一项调查，这项调查不仅涵盖了纯粹的 HTML，还涉及了可访问性、Web 组件等等。 👉🏻原文链接：HTML 2023 不依赖框架，利用 css 完成布局模板这篇文章《Modern CSS Layouts: You Might Not Need A Framework For That》介绍了在现代CSS开发中，如何不依赖于框架而使用CSS本身的强大功能来创建灵活的布局。作者展示了如何利用CSS的网格（Grid）和弹性盒（Flexbox）布局，以及如何通过CSS变量和级联层（Cascade Layers）来创建可重用的布局类。这些技术允许开发者创建响应式、可配置的布局，而无需依赖外部框架，从而简化了代码并提高了性能和可维护性。 👉🏻原文链接：不依赖框架，利用 css 完成布局模板 利用 CSS 基于时间的方式制作动画这篇文章讲述了如何使用CSS Houdini API和数学函数实现基于时间的CSS动画，而不是传统的关键帧动画。作者介绍了一种方法，通过自定义属性随时间递增来启动动画，使动画能够动态适应。内容涵盖了如何控制帧率、利用数学函数来创造运动模式（如正弦往复运动）以及如何使用数学表达式创建自定义的缓动函数。此外，文章还探讨了如何实验性地使用CSS属性和值，以实现更复杂和响应式的动画设计。 👉🏻原文链接：利用 CSS 基于时间的方式制作动画 利用 CSS 实现倒计时动画通过组合 @property @keyframes animation counter-reset counter 属性实现倒计时动画。 @property 定义变量 –n @keyframes 定义动画区间 animation 执行动画，改变变量 –n 的值 counter-reset 计算 count 的值 counter 将内容交给 content最小 demo 示例123456789101112131415@property --n { syntax: &quot;&lt;integer&gt;&quot;; inherits: false; initial-value: 0;}@keyframes count { from { --n: 5; } to { --n: 0; }}.timer:hover::after { animation: 5s linear count; animation-fill-mode: forwards; counter-reset: n calc(0 + var(--n)); content: counter(n);} 👉🏻原文链接：利用 CSS 实现倒计时动画 工具推荐lmstudio.ai一款在您的笔记本电脑上完全离线运行LLMs👾 支持从 HuggingFace 🤗存储库下载任何兼容的模型文件 texttospeech免费的在线文字转换语音工具，支持多种语言类型选择。","link":"/2024/06/25/2024/0x20240625/"},{"title":"前端早读精选 - setTimeout 带来的内存泄漏风险！","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **JS 文章推荐**：setTimeout 潜在的内存泄漏风险、Promise 基础教学、单页面应用中的数据获取模式、webhooks 简介。 **HTML &amp; CSS 文章推荐**：4 种利用 CSS 实现入场出场动画、使用 CSS 中的 conic-gradient()创建文本逐渐显露效果。 **工具推荐**：现代全栈Web应用开发工具 - **Wasp**、基于 WebRTC 的点对点传输工具 - **sharedrop**。 如果觉得有收获，欢迎大家点赞👍🏻订阅 JS 文章推荐setTimeout 潜在的内存泄漏风险这篇文章探讨了在 Node.js 中使用 setTimeout 可能导致内存泄露的问题。Node.js 中的 setTimeout 返回的是一个包含多个属性的 Timeout 对象，而不是简单的数字。如果这些 Timeout 对象未被及时清除，它们可能维持对一些资源的引用，从而导致内存无法释放。特别是 Timeout 对象可以充当更多状态的容器，如 AsyncLocalStorage 的新 API，它会将附加状态附加到所有触发超时的操作上。异步本地存储是以这样一种方式实现的，即Timeout 对象会将隐藏状态一直传递下去，直到它们运行。 一句话总结：对于定时器在清除时，最好也将其引用清除 12clearTimeout(this.timer);this.timer = null; 代码 示例详情 👉🏻原文链接：setTimeout 潜在的 Node 内存泄漏风险 Promise 基础教学一篇很不错的 JavaScript 异步编程的演进过程，介绍了从早期 JavaScript 在异步编程方面面临的问题到最后的解决方案。最初，使用回调函数虽然实现了异步操作，但很快因代码复杂和难以维护而导致“回调地狱”。为解决这一问题，Promises被引入，提供了更清晰的异步管理方法。随后，Async/Await作为对Promises的进一步抽象，通过更直观的同步方式书写代码，简化了异步编程的复杂性，极大地改进了代码的可读性和错误处理能力。 👉🏻原文链接：Promise 基础教学 单页面应用中的数据获取模式这篇文章探讨了在单页面应用中获取数据的模式，重点是如何在获取远程数据时保持应用的响应性。介绍了五种模式：异步状态处理器、并行数据获取、回退标记、代码分割和预获取。每种模式都旨在优化加载时间，改进用户体验，且具有特定的应用场景。文章通过实例展示了如何在React中实现这些模式，并讨论了各模式的适用情况。 👉🏻原文链接：单页面应用中的数据获取模式 什么是 webhooks很好的一篇 webhooks 科普文。文章介绍了 Webhooks 的基础知识和实现方式。Webhooks 是基于 HTTP 的回调函数，允许服务通过 API 通知其他服务事件发生。它们是事件驱动的，可以即时传递数据，避免了频繁的轮询，提高了效率。文章还通过 GitHub 的例子展示了如何设置和接收 Webhooks，包括安全性和有效性的验证。Webhooks 的好处包括实时数据传输、提高用户体验、定制化触发特定动作等，还建议了一些最佳实践，如使用 HTTPS、验证 Webhooks、错误处理和日志记录。这些使得 Webhooks 成为提高工作流、响应性和效率的有效工具。现在很多办公的 IM 软件的机器人体系亦或者 CI、CD 系统，在与团队各个业务系统打通，本质上就是基于 webhooks 去实现的。 附：网页的 Ajax 请求与 webhooks 之间的区别。从技术实现上它们很相似，但它们的使用场景和行为约束确实有所不同： Webhook：更适用于服务器之间的异步通信，允许系统在事件发生时主动通知其他系统，常用于实现实时数据同步、通知和自动化工作流程。 Ajax：更适合于在用户与页面交互时进行数据的异步加载和更新，通过 AJAX 技术可以在不刷新整个页面的情况下实现部分内容的更新，适用于增强用户体验和实现动态交互。虽然它们在技术实现上相似，数据消费与使用场景存在差异。 👉🏻原文链接：什么是 webhooks CSS 文章推荐四种新的 CSS 特性，用于实现流畅的进入和退出动画这篇文章介绍了 Chrome 116 和 117 版本中引入的四个新的 CSS 功能，旨在改进网页元素的进入和退出动画。这些功能包括在关键帧时间线上动画化 display 和 content-visibility 属性，使用 transition-behavior 属性中的 allow-discrete 关键字来转换离散属性，以及 @starting-style 规则和 overlay 属性来控制元素动画过程中的层级行为。这些新特性让开发者能够更加平滑和自然地实现复杂动画效果。 👉🏻原文链接：四种新的 CSS 特性，用于实现流畅的进入和退出动画 使用 CSS 中的 conic-gradient()创建文本逐渐显露效果这篇文章介绍了如何使用 CSS 的 conic-gradient() 实现一个文本逐渐显示的效果。首先，设置了一个简单的 HTML 文本作为“掩码”，在此基础上，使用 conic-gradient() 为容器元素创建背景渐变。随后，通过 CSS 变量控制渐变的尺寸和重复性，实现文本的动态显示。为了增加互动性，作者将文本显示动画与用户悬停操作关联起来。最后，通过修改 CSS mix-blend-mode 属性完成了最终的文本显示效果。 👉🏻原文链接：使用 CSS 中的 conic-gradient()创建文本逐渐显露效果 工具推荐waspWasp 是一个现代全栈Web应用开发工具，它不仅仅是帮助开发者进行类型定义，而是提供了一个更广泛的开发框架。它集成了前端、后端和数据库的开发流程，利用React、Node.js和Prisma等技术。Wasp 的编译器可以自动处理各种配置和代码生成，从而简化了身份验证、数据库操作、异步处理等多种功能的实现。开发者只需要在Wasp的配置文件中声明应用逻辑，Wasp 会自动转换成完整的应用程序代码。 举个🌰：在 main.wasp 上进行 Prisma 类型定义 根据 wasp 服务端定义接口数据获取 跟 wasp 前端进行数据获取 sharedropShareDrop 是一款受苹果 AirDrop 服务启发的网络应用。它允许您在设备之间直接传输文件，无需先将文件上传到任何服务器。它使用 WebRTC 进行安全的点对点文件传输，并使用 Firebase 进行在线状态管理和 WebRTC 信令。ShareDrop 和 AirDrop 之间的主要区别在于 ShareDrop 需要互联网连接来发现其他设备，而 AirDrop 则不需要，因为它在它们之间创建了临时无线网络。另一方面，ShareDrop 允许您在移动设备（Android 和 iOS）和桌面设备之间甚至在网络之间共享文件。 观点一个关于前端开发的抱怨这篇文章是一位资深前端开发者对当前前端开发领域的一系列批评。作者批判了当代前端开发忽视内容本质、过度依赖 JavaScript 和复杂框架的趋势。他提出，许多开发者忘记了简单性的重要性，使用复杂的解决方案去解决本可以简单处理的问题。此外，他还批评了现代工具和方法，如Sass和各种前端框架，认为这些只是增加了不必要的复杂性和技术负债。作者恳求开发者回归简单、直观的开发方式，减少不必要的技术堆砌，重视内容和用户体验而非仅仅是技术本身。 一句话总结：关于对于前端开发人员为简单问题创建复杂解决方案感到愤怒的抱怨。你怎么看？","link":"/2024/07/16/2024/0x20240716/"},{"title":"掌握SVG：前端早读精选教你绘制任何图形","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **JS 文章推荐**：如何在 SVG 绘制任意图形、NodeJS 实验性 API 支持 Typescript、全栈网络推送 API 指南、如何通过 hack 的方式提升 Lighthouse 评分 **HTML &amp; CSS 文章推荐**：CSS 新的查询方式 – 容器查询、CSS 锚定语法实践指南 **工具推荐**：如何利用 cron 在 Linux 中实现定时任务、SVG 绘制可视化工具 – **svg-path-visualizer**、利用 canvas 实现彩带效果 – canvas-confetti 如果觉得有收获，欢迎大家点赞👍🏻订阅 JS 文章推荐如何在 SVG 绘制任意图形这篇文章讲述了如何在SVG中进行任意路径的变形动画。作者介绍了SVG路径的基本组成和转换方法，特别是如何将不同类型的绘图命令转换为三次贝塞尔曲线，以便进行动画处理。此外，还讨论了如何通过程序匹配不同路径的点数和结构，以实现两个路径之间的平滑变形。并提供了一个交互式示例来展示这些技术如何实际应用于SVG动画中。 衍生阅读：svg 中的动画标签 标签 说明 使用 GPU/CPU &lt;animate&gt; 此标签用于基本的属性动画，如改变颜色、大小等 CPU &lt;animateColor&gt; 专门用于颜色动画，例如平滑地改变元素的颜色 CPU &lt;animateMotion&gt; 允许元素沿着路径移动 GPU &lt;animateTransform&gt; 用于动画化变换属性，如旋转、缩放和位移 GPU &lt;set&gt; 用于立即设置一个属性值，而不是创建一个动画序列 CPU &lt;discard&gt; 虽然不是严格意义上的动画标签，但用于控制元素何时应该被丢弃或停止显示 - 👉🏻原文链接：如何在 SVG 绘制任意图形 NodeJS 增加对TS支持Node.js 添加了对 TypeScript 的实验性支持。初始实现通过设置实验性标志 --experimental-strip-types 来执行 TypeScript 文件。值得注意的是，NodeJS 对 TypeScript 的支持实现上，是将TypeScript 源代码转译为 JavaScript 源代码，并且在转义过程中不进行类型检查，类型将会被丢弃。关联PR 👉🏻原文链接：NodeJS 增加对TS支持 全栈网络推送 API 指南这篇文章是关于如何在一个基于 remix.run的应用中实现完整的Web推送通知系统。详细介绍了创建一个支持推送通知的全栈Web应用的过程，包括 service worker 的设置、前端和后端的订阅管理，以及如何使用 Web 推送 API 和 service worker API 发送通知。文章包含了完整的开发指南和代码示例，帮助开发者从头开始构建或整合到现有的 Remix 应用中。 👉🏻原文链接：全栈网络推送 API 指南 如何通过 hack 的方式提升 Lighthouse 评分 文章探讨了 Google Lighthouse 如何计算其性能得分，每个指标在 Lighthouse 中的规则以及影响权重。在规则的基础上如何利用这些信息，通过 Hack 的手段影响 Lighthouse 的评分。 附：指标与权重 Metric Weighting (%) Total Blocking Time 30 Cumulative Layout Shift 25 Largest Contentful Paint 25 First Contentful Paint 10 Speed Index 10 👉🏻原文链接：如何通过 hack 的方式提升 Lighthouse 评分 CSS 文章推荐CSS 容器查询CSS 容器查询的主要思想是将一个元素注册为“容器”，并在容器元素满足特定条件时，对其他元素应用样式。例如： 1234567.parent { container-name: hero-banner; container-type: inline-size; }.child { display: flex; flex-direction: column; }/* 当容器宽度大于 60ch 时应用下面的样式 */@container hero-banner (width &gt; 60ch) { .child { flex-direction: row; }} 👉🏻原文链接：CSS 容器查询 CSS 锚点定位入门指南这篇文章介绍了 CSS 锚点定位（Anchoring API），包括其基本用法和两种主要方法：使用 anchor() 函数和 inset-area 语法。总结如下： 锚点定位的基本概念： 锚点定位允许将一个元素的定位基于另一个元素，使用 CSS 的 anchor() 函数和 inset-area 语法。 anchor-name 和 position-anchor 属性： anchor-name 用于定义一个元素的锚点名称。 position-anchor 用于将另一个元素的定位锚定到指定的 anchor-name。 **回退选项 position-try-options**： 提供多个回退选项，确保在视口中尽量保持元素可见。 选项包括 normal、contain 和 center 等。 **自定义回退选项 @position-try**： 可以定义多个尝试定位的策略，指定不同的定位方案和优先级。 注意，当前浏览器支持情况并不友好。 👉🏻原文链接：CSS 锚点定位入门指南 工具推荐如何利用 cron 在Linux中实现定时任务文章介绍了在Linux系统中如何使用cron和crontab进行任务计划。Cron是一个基于时间的作业调度程序，可用于定期执行命令或脚本。 能力 具体操作 创建cron作业 使用命令crontab -e编辑用户的crontab文件 管理cron作业 列出当前用户的cron作业crontab -l 删除cron作业 使用命令crontab -r删除用户的crontab文件 设置系统级cron作业 直接编辑/etc/crontab文件添加作业 调试cron作业 检查cron作业日志，确认环境变量和路径设置 👉🏻原文链接：如何利用 cron 在Linux中实现定时任务 svg-path-visualizer将绘制 SVG 的参数可视化，通过参数与绘制结果一一映射解析，帮助你快速了解 SVG path 语法对应的渲染表现。 👉🏻原文链接：svg-path-visualizer canvas-confetti🎉 浏览器中的高性能彩带动画。confetti 接受一个可选的对象。支持 Promise 时返回 Promise。不支持时返回 null。如果在 confetti 完成之前多次调用它，每次都会返回相同的 Promise。在内部，将重用同一个画布元素，继续现有的动画并添加新的彩屑。每次调用 confetti 返回的 Promise 一旦所有动画完成就会被解析。 👉🏻原文链接：canvas-confetti","link":"/2024/08/16/2024/0x20240816/"},{"title":"前端早读精选：ECMAScript 2024 新标准","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章。 **JS 文章推荐**：使用 React 18 提升《纽约时报》的网页性能、ECMAScript 2024 新功能、好的重构 VS 坏的重构 **NodeJS 文章推荐**：如何在 Node 应用中捕获 GC 记录、不要阻塞事件循环 **HTML &amp; CSS 文章推荐**：使用 CSS 控制网页打印样式 **工具推荐**：轻量级 Web Component 库 - Lit、自动生成更新日志 - git-cliff、超 500 种让页面重新加载的方案、性能更优体积更新的工具函数库 - es-toolkit 如果觉得有收获，欢迎大家点赞👍🏻订阅 JS 相关推荐使用 React 18 提升《纽约时报》的网页性能《纽约时报》团队最近通过升级 React 18 成功提升了网站的性能。这次迁移带来了多方面的性能优化，主要体现在以下几个方面： 自动批处理（Automatic Batching）：React 18 可以将多次状态更新合并到一次渲染周期内，从而减少主线程的负载，提升整体运行效率。 过渡钩子（useTransition）：这个新特性确保界面更新不会阻塞用户界面，使得交互更加流畅。 服务端渲染改进：React 18 的新功能——React Server Components，允许流式更新内容，提升了首屏加载速度，并支持更多创新的 UI 模式。 性能指标改进：通过这次升级，纽约时报的“Interaction to Next Paint (INP)”指标显著提高，这对 SEO 排名和用户体验都有重要影响。同时也碰到了 hydration 时，客户端与服务端 DOM 不一致的问题，通过方法来提取并替换 &lt;script&gt; 标签，确保脚本在客户端正确加载，并通过优先级管理控制脚本的执行顺序，来确保前后 DOM 一致性。 👉🏻原文链接 ECMAScript 2024 新功能2024 年 6 月 26 日，第 127 届 Ecma 大会批准了 ECMAScript 2024 语言规范，这意味着它现在正式成为一个标准。快来看看新版本中都有哪些新特性吧。以下是省流版本 新功能 描述 Map.groupBy() 和 Object.groupBy() 将迭代器的项按指定规则分组 Promise.withResolvers() 简化 Promise 的创建，返回 Promise 及其解析器 正则表达式标志 /v 支持 Unicode 字符属性和集合运算 可调整大小的 ArrayBuffer 支持 ArrayBuffer 的大小调整和转移 .isWellFormed() 和 .toWellFormed() 确保字符串符合 UTF-16 规范 Atomics.waitAsync() 在共享内存上进行异步等待 附 Atomics.waitAsync 的一个实际使用场景，当内存内容发生变化后，再执行后续代码，例如： 12345678910111213141516171819const sharedBuffer = new SharedArrayBuffer(4);const sharedArray = new Int32Array(sharedBuffer);// 消费者async function consumer() { console.log('Waiting for value to be updated...'); await Atomics.waitAsync(sharedArray, 0, 0).value; console.log('Value updated to:', sharedArray[0]);}// 生产者function producer() { console.log('Producing value...'); sharedArray[0] = 42; Atomics.notify(sharedArray, 0);}consumer(); // 启动消费者setTimeout(producer, 1000); // 1秒后生产数据 👉🏻查看原文链接 好的重构 VS 坏的重构这篇文章讨论了代码重构的好与坏，重点是避免无效或有害的重构。作者提到，好的重构能提高代码的可读性和维护性，而坏的重构则会增加复杂性，使代码更难理解和维护。文章举例说明了常见的错误，如引入过多的抽象、不必要的库、风格不一致等。最后强调了渐进式修改、深刻理解代码和一致性的重要性。 附：对于风格一致性观点补充。很多时候程序员会认为新的技术就是好的，忽略了业务特点以及团队规范，往往这些新特性的引入，会对团队的整体代码质量带来很大的风险。之前笔者所在的团队，部分同时推崇函数式编程，部分同事更喜欢直接使用面向对象编程，这就导致一个项目中，会出现多种风格的代码，极大的加大了新手对于项目的理解与上手成本。👉🏻查看原文链接 NodeJS 相关推荐如何在 Node 应用中捕获 GC 记录在NodeJS应用中，分析垃圾回收（GC）迹象对于诊断内存问题和维护最佳性能至关重要。文章探讨了三种捕获GC迹象的方法：使用 –trace-gc 标志、利用 perf_hooks 模块和使用 v8 模块。每种方法都有其独特的优点和适用场景，但也存在可能影响应用性能的局限性。 以下是这三种方法的优缺点总结表： 方法 优点 缺点 –trace-gc 标志 简单易用，提供即时反馈 持续日志记录可能影响性能，控制限制 perf_hooks 模块 提供详细洞察，灵活监控 设置复杂，监控GC可能引入性能开销 v8 模块 动态控制GC追踪，专注调试关键部分 使用复杂，开启GC追踪时仍有性能开销 👉🏻查看原文链接 不要阻塞事件循环来自 NodeJS 官方的 Node 性能优化指南，文章解释了如何避免在Node.js中阻塞事件循环和工作池。关键优化建议包括：避免长时间的同步任务，使用异步任务拆分，将计算密集型任务移交给工作池，以及使用setImmediate()或process.nextTick()来优化任务执行时机。通过这些方法，可以防止单个任务占用主线程过多时间，从而提升应用程序的并发性能和响应速度。 👉🏻查看原文链接 CSS 推荐使用 CSS 控制网页打印样式该文章详细介绍了如何使用 CSS 为打印设计网页，涵盖了 @page、@media print、宽高及边距的设置等关键内容。作者通过实际项目分享了如何利用 CSS 控制页面布局，避免打印时常见的问题，如双重边距或内容溢出。同时，文章讨论了生成多页文档时如何重复元素、处理表格分页等问题，并提供了实用的 CSS 和 JavaScript 示例，帮助开发者构建自定义的打印样式。 👉🏻查看原文链接 工具推荐litLit 是一个用于构建快速、轻量级 Web Component 库。Lit 的核心是一个能够消除模板代码的组件基类，它提供了响应式状态管理、作用域样式，以及一个小巧、快速且富有表现力的声明式模板系统。 👉🏻查看原文链接 超过500种网页重新加载的方式该站点收入了 500 种重新加载网页的方式，例如： 1234location = locationlocation = location.hreflocation = window.location... 👉🏻查看原文链接 git-cliffgit-cliff可以利用传统提交和基于正则表达式的自定义解析器，从Git历史记录中生成变更日志文件。可以使用配置文件定制变更日志模板以匹配所需的格式。 👉🏻查看原文链接 es-toolkites-toolkit 是一个先进的、高性能的 JavaScript 实用工具库，具有小的捆绑包大小和强大的类型注解。 es-toolkit 提供多种现代实现的日常实用函数，如 debounce、delay、chunk、sum 和 pick。 设计时考虑了性能，es-toolkit 在现代 JavaScript 环境中实现了 2-3 倍的性能提升。 es-toolkit 支持开箱即用，并且与其他库相比，可以将 JavaScript 代码减少高达 97%。 es-toolkit 包含内置的 TypeScript 支持，提供直观且强大的类型。它还提供诸如 isNotNil 等有用的类型保护。 es-toolkit 经过了百分之百的测试覆盖率的实战检验，确保其可靠性和稳健性。 👉🏻查看原文链接","link":"/2024/10/09/2024/0x20241009/"},{"title":"前端早读精选 - 第一期","text":"探索前端技术的无尽旅程从这里开始！每周精选前端领域的热门文章，在这份汇总中，发现前端技术的精髓，概括个人观点，共同探索前沿技术与行业动向。与笔者一起在每周的学习中前行，不容错过的前端精选，助力你成为技术领域的探索者。 1. Ant Design Web3发布啦！Ant Design 作为前端 UI 组件库的老牌选手，正式发布 针对 web 3.0 社区的 UI 特性的组件库。除了提供了连接Web3 DApp所需的组件外，还额外提供了和链的交互的能力，支持以太坊及兼容EVM的链。具有通用API，适配不同区块链的能力。可作为纯UI组件使用，也提供适配器连接区块链。 2. structuredClone浏览器原生自带的深拷贝函数你是否还在为如何处理深拷贝一个未知数据类型对象而烦恼，使用 JSON.parse(JSON.stringify) 担心部分数据类型处理不符合预期（如 Date 会被处理为字符串），使用 lodash 又担心 tree-shaking 处理不当带来包体积的增长。现在这些烦恼，使用 structuredClone 都将被解决。当然我们还需要考虑其使用时的一些隐患。 浏览器兼容性 部分无法处理：函数、Dom 节点、属性描述符（setter、getter）、对象原型 3. AI 自动创建 React 组件 – V0Vercel 提供的代码生成工具让用户只需输入自己的需求，即可生成相应的 React 代码。对于使用 NextJS 框架的用户，更可享受一键直接安装使用的便捷。在笔者的试用中，简单场景下生成的组件基本可用，然而在复杂的需求描述中，生成的代码则显得不够实用。（PS：可能对中文的理解有限😅） 4. 总结：javaScript 与 TypeScript 在过去三年的全部新特新 有多少同学与笔者一样，在 ES6 推出后对 EScript 的新特性与规范关注甚少。通常，我们更多地依赖外部的技术文章获取关于这些新特性的信息，而在实际的应用中，除了一些常用的，其他新特性的了解相对较少。本文对过去三年内 JS 与 TS 的新特性进行了综合梳理。希望在我们完成日常需求之后，能够抽出时间深入了解这些新特性的使用，除了查漏补缺外，还可以了解它们背后创作的原因。 5. 年终总结：回顾一下 Robin Wieruch 的 2023 10个前端发展趋势 (META) FRAMEWORKS： 单页应用程序（SPA）及其相关框架（如React.js、Vue.js、Svelte.js）经历了多轮炒作，但最近几年，元框架的崛起表明应用程序正在从客户端渲染（CSR）转向服务器端渲染（SSR）。其中，Next.js成为最受欢迎的元框架之一，它在React.js的基础上提供了全方位的支持，为开发人员提供了出色的开发体验。 APPLICATION AND RENDERING PATTERNS： 过去十年一直被单页应用程序（SPA）主导，但最近几年对服务器端渲染（SSR）的兴趣不断增加。新兴的渲染技术，如增量静态再生（ISR）和流式SSR，正在改变渲染模式，为更细粒度的性能优化提供可能。 SERVERLESS AT THE EDGE： SSR和SSG的流行与无服务器边缘计算的趋势高度相关，旨在提供更快的网页和Web应用程序体验。各云服务提供商（例如Cloudflare、Vercel和Deno）竞相推出边缘计算服务，以实现最佳的时间交互体验。 DATABASE RENAISSANCE： 随着无服务器的崛起，数据库也经历了复兴。服务商如PlanetScale、Neon和Xata提供了与边缘缓存等功能结合的服务器数据库服务，为全球用户提供低延迟的数据交互。 JAVASCRIPT RUNTIMES： 从Node.js到Deno，JavaScript运行时的竞争激烈。云服务提供商通过实施自己的JavaScript运行时（如Cloudflare Workers）来优化基础设施，这使得JavaScript运行时的多样性成为需要关注的问题。 MONOREPOS： 单体仓库不再仅用于大型应用程序，而是成为小型公司和开源项目的热门选择。Turborepo等工具推动了单体仓库的热潮，使团队能够在单一版本控制存储库中构建所有应用程序和包。 UTILITY-FIRST CSS： Tailwind CSS等实用主义CSS工具在近期崛起，尤其在服务器端渲染（SSR）的环境中表现出色。相较于CSS-in-JS的解决方案，实用主义CSS在SSR环境下具有更好的性能。 END-TO-END TYPE SAFETY WITH TYPESCRIPT： JavaScript向TypeScript的演进不可阻挡。端到端的类型安全性在全栈应用中变得愈发重要，而使用OpenAPI或GraphQL Code Generator等工具可以实现对客户端和服务器端通信的类型安全。 BUILD TOOLS： Vite取代了一度主导React领域的create-react-app（CRA），成为单页应用程序的新宠。它借助esbuild实现更快的依赖项捆绑，为前端开发提供了更高效的工具。 AI DRIVEN DEVELOPMENT： GitHub Copilot和ChatGPT等工具为AI驱动的开发奠定了基础。开发者可以在其IDE中与AI程序员进行合作，实现代码的智能自动补全。 从笔者今年的经历来看，谈一下几个对自己感受比较大的方向 MONOREPOS：随着业务的增长，前端不再是简单的单业务单页面模式，更多的是领域模式。如交易领域、流量领域。每个领域都有着自己的特性，monorepo 的组织方式能够更有效的加速业务基础能力的沉淀。同时 Lerna、rushstack等管理工具，有效较低了工程化的解决成本。 JAVASCRIPT RUNTIMES：除了 Deno 与 NodeJS 的竞争，Bun 也是有利竞争者之一。 BUILD TOOLS： 今年看到的更多内容是构建性能提升，使用 rust 改写底层库的构建工具越来越多，作为一名前端，需要对 rust 保持一定的关注。 AI DRIVEN DEVELOPMENT： AI 绝对是今年最爆💥的方向，没有之一。各类好用的 AI 工具，让开发效率得到了极大提升。笔者现在已经深度依赖 Copilot 和 ChatGPT。 6. 年终总结：更快的 V8 引擎回顾 2023 年，V8 引擎主要做了以下事情 一个新的中间层编译器：Maglev。它的工作介于Sparkplug和TurboFan编译器之间。在机器码生成方面，相较于 Sparkplug 慢大约 20 倍，在机器码优化上，相较于 TurboFan 快了 10 到100倍 Turboshaft：顶层优化编译器的新架构。与 CPU 无关的后端操作编译速度提升了两倍 更快的 HTML 解析器、更快的 DOM 分配 JavaScript 新特性支持、更友好的 WebAssembly 支持 安全性能提升 附：Chrome V8 引擎中，Sparkplug、TurboFan、Maglev 引擎的工作职责 Sparkplug：Sparkplug 是 V8 引擎的初始编译器，它负责将 JavaScript 代码转换为机器码。Sparkplug 使用的是基于栈的架构，它可以快速生成机器码，但效率较低。 TurboFan：TurboFan 是 V8 引擎的优化编译器，它负责对 Sparkplug 生成的机器码进行优化。TurboFan 使用的是基于寄存器的架构，它可以生成更高效的机器码，但速度较慢。 Maglev：Maglev 是 V8 引擎的实验性编译器，它是 TurboFan 的替代方案。Maglev 使用的是基于 SSA（Static Single Assignment）的架构，它可以生成更高效、更易于优化的机器码。 Sparkplug 和 TurboFan 是 V8 引擎中的主要编译器，它们共同负责将 JavaScript 代码转换为机器码。Sparkplug 负责快速生成初始机器码，TurboFan 负责对初始机器码进行优化。 7. github 热门前端项目7.1 专为开发者提供的便签App – heynoteHeynote是一个专门为开发者准备的便签本。它的功能是作为一个大的持久文本缓冲区，您可以在其中写下任何您喜欢的内容。比较适合随手记录一些信息，支持快速新增 block，每个 block 都有自己的特性，如 Math block、markdown block、javaScript block 等 7.2 极简个人网站 – Shiro喜欢极简主义的同学注意啦！如果你想搭建一个极简风格个人网站，那么 Shiro 将会是一个不错的选择。 8. 杂七杂八 一个检查自己账户是否安全的网站 免费使用 Google Gemini 结语在这篇文章中，我们一同踏上前端技术的无尽旅程，每周探索前沿技术。Ant Design Web3、structuredClone、Vercel的AI自动生成React组件，以及JavaScript与TypeScript的新特性，展示了前端不断创新的面貌。Robin Wieruch的趋势总结指出了元框架崛起、无服务器边缘计算等重要方向。2023年，V8引擎的升级、AI驱动开发的兴起，为前端开发带来了更高效的工具和性能提升。同时，推荐了Heynote和Shiro等热门前端项目。在新的一年里，让我们继续前行，共同迎接更多前端技术的挑战与创新，成为技术领域的探索者。前端技术之旅永无止境，愿我们共同创造更精彩的前端未来！ 个人私货 科技周刊 属性描述符，setter 和 getter 123// 例如，使用 getter 时，会克隆结果值，但不会克隆 getter 函数本身（或任何其他属性元数据）：structuredClone({ get foo() { return 'bar' } })// Becomes: { foo: 'bar' } 对象原型 // 原型链不会被遍历或重复。因此，如果您克隆 的实例`MyClass`，则克隆的对象将不再被认为是该类的实例（但该类的所有有效属性都将被克隆） class MyClass { foo = 'bar' myMethod() { /* ... */ } } const myClass = new MyClass() const cloned = structuredClone(myClass) // Becomes: { foo: 'bar' } cloned instanceof myClass // false","link":"/2023/12/29/2023/0x20231229/"},{"title":"浏览器手绘画画","text":"前言今天给大家介绍一个工具 – Atrament。 Atrament是一个用于在 HTML 画布上进行美丽绘制和手写的小型 JS 库。适用场景如：网上签约时用户签名、需要手绘动画。阅读完本文你会有以下收获： 了解Atrament 的基本使用 从实践出发，手把手教你实现一个简易画布编辑器 下述实践代码已提交至 github，点击直接查看源码 Atrament 介绍Atrament 是一个用于在 HTML 画布上绘制和手写的库。它的目标是让绘图感觉自然舒适，结果平滑愉悦。Atrament 不会存储笔画路径本身 - 相反，它会直接绘制到画布位图上，就像一支墨水笔在一张纸上一样（“atrament”在斯洛伐克语和波兰语中意为墨水）。这使得它适用于某些应用程序，但对其他应用程序来说并不完全理想。它具备以下特点： 丰富的编辑能力：支持绘制/填充/擦除模式 自适应平滑：可调自适应平滑，让画笔更像手绘 丰富的事件系统：支持跟踪绘图的事件 画笔调节：支持画笔粗细与颜色调整。 ⚠️ 注意：从版本 4 开始，Atrament 支持常青浏览器（Firefox、Chrome 和基于 Chromium 的浏览器）以及 Safari 15 或更高版本。如果您的应用程序必须支持旧版浏览器，请使用版本 3。您可以在这里查看 v3 的文档。 Atrament 实践接下来将以 React + Atrament 实现一个画画面板。该画板具备以下功能： 背景设置 编辑面板：支持设置画笔粗细、颜色、平滑度、橡皮擦。 操作面板：上一步、下一步、下载图片。 画布创建创建一个 Atrament 画布非常简单，只需要创建一个 canvas 标签，并实例化 Atrament 即可。 1&lt;canvas id=&quot;sketchpad&quot;&gt;&lt;/canvas&gt; 获取节点，并实例化 Atrament，以 react 工程示例 123456789101112131415import Atrament from 'atrament';const App = () =&gt; { const canvasRef = useRef(null); const sketchpadRef = useRef(null); useEffect(() =&gt; { const canvas = canvasRef.current; sketchpadRef.current = new Atrament(canvas, { width: canvas.offsetWidth, height: canvas.offsetHeight, }); }); return &lt;canvas ref={canvasRef}&gt;&lt;/canvas&gt;} 到这里，画布初始化就完成了！ 需要注意的是，为了使绘图在高 DPI 屏幕上显示清晰，自 v4.0.0 版本起，Atrament 通过 window.devicePixelRatio 来调整其绘图上下文的大小。这意味着当您设置自定义 width 或 height 时，还要将 CSS 像素值乘以 devicePixelRatio 。 draw() 接受和包含的描边事件的值始终为 CSS 像素。如上述例子，在 DPI 为 2 的机器里，实际渲染出来的 canvas 会是 1000*1000。 在初始化画布的宽高的时候，最好根据 canvas 的宽高设置 width 与 height，否则可能会出现鼠标绘制的起始点与画布渲染的起始点不一致，代码示例 12345const canvas = document.querySelector('#sketchpad');const sketchpad = new Atrament(canvas, { width: canvas.offsetWidth, height: canvas.offsetHeight,}); 接着给画布加上一点点样式，预留出编辑区与画布区。加完样式后，表现如下： 背景功能增加Atrament 的绘画共有四种模式 MODE_DRAW（默认）：绘画模式 MODE_ERASE：擦拭模式 MODE_FILL：填充模式 MODE_DISABLED：不对画布做修改，但仍然触发stroke事件 实现背景填充，可以使用 MODE_FILL模式。首先通过 input 实现一个颜色选择器（color-picker），它将作为背景颜色的选择工具。通过选择不同的颜色，可以实现背景的填充效果。 由于 Atrament 并没有提供填充背景的 API 调用，这里使用的是记录上次 mode 与 color，在用户选择完成背景色后，点击画布，切换背景，再次操作切换为上次的 mode 与 color。 12345678910111213141516// 背景色设置const onBgColorPick = (event) =&gt; { const ctx = sketchpadRef.current; const color = event.target.value; prevModeInfoRef.current.mode = ctx.mode; prevModeInfoRef.current.color = ctx.color; ctx.mode = MODE_FILL; ctx.color = color;};// 填充完成后，复位，可在初始化实例那里监听sketchpadRef.current.addEventListener('fillend', () =&gt; { sketchpadRef.current.mode = prevModeInfoRef.current.mode; sketchpadRef.current.color = prevModeInfoRef.current.color;}); 实现效果如下： 编辑功能增加实现画笔粗细、颜色、平滑度、橡皮擦这些功能都比较简单。其中粗细、颜色、平滑度都是使用Atrament 实例上的属性： weight：设置画笔粗细，默认值为 2px。 color：设置画笔颜色，默认值为 #000 smoothing: 设置画笔的丝滑度，默认为 0.85 通过 input 控件来控制画笔的各种属性变化： 1234const onPenBaseInfoChange = (type, isNumber) =&gt; (event) =&gt; { const targetVal = event.target.value sketchpadRef.current[type] = isNumber ? +targetVal : targetVal;} 1234567891011121314&lt;div className='editItem'&gt; &lt;label&gt;画笔粗细设置&lt;/label&gt; &lt;input type='range' min=&quot;0&quot; max=&quot;100&quot; onInput={onPenBaseInfoChange('weight', true)} step={1} defaultValue={sketchpadRef.current?.weight || 2} /&gt;&lt;/div&gt;&lt;div className='editItem'&gt; &lt;label&gt;画笔平滑度&lt;/label&gt; &lt;input type='range' min=&quot;0.1&quot; max=&quot;2&quot; onInput={onPenBaseInfoChange('smoothing', true)} step={0.05} defaultValue={sketchpadRef.current?.smoothing || 0.85} /&gt;&lt;/div&gt;&lt;div className='editItem'&gt; &lt;label&gt;画笔颜色&lt;/label&gt; &lt;input onInput={onPenBaseInfoChange('color')} type=&quot;color&quot; defaultValue='#000'&gt;&lt;/input&gt;&lt;/div&gt; 编辑功能设置的功能添加后，效果如下： 橡皮擦需要将 Atrament 的mode设置为MODE_ERASE。这里涉及到画笔模式切换，在切换成橡皮擦之前，先缓存一下画笔粗细，同时将橡皮擦的粗度调大，方便擦拭。代码如下： 123456789101112const chooseErase = () =&gt; { const ctx = sketchpadRef.current; prevModeInfoRef.current.weight = ctx.weight; ctx.mode = MODE_ERASE; ctx.weight = 40;}const choosePen = () =&gt; { sketchpadRef.current.mode = MODE_DRAW; sketchpadRef.current.weight = prevModeInfoRef.current.weight || 2;} 123456&lt;div onClick={chooseErase} className='editItem'&gt; 橡皮擦🧽&lt;/div&gt;&lt;div onClick={choosePen} className='editItem'&gt; 画笔✏️&lt;/div&gt; 橡皮擦实现效果如下： 操作面板接下来通过缓存用户操作记录，实现上一步与下一步。首先通过启动recordStrokes与监听strokerecorded 事件来缓存用户操作。同时建立一个索引来标记用户的最新操作。 注意 strokerecorded事件会在短时间内重复触发两次，所以这里简单采用了一个节流处理 12345678910111213141516171819const recordDate = useRef(Date.now());const recordRef = useRef([]);const editIndex = useRef(0);useEffect(() =&gt; { ... sketchpadRef.current.recordStrokes = true; sketchpadRef.current.addEventListener('strokerecorded', ({ stroke }) =&gt; { // 防止重复 if (Date.now() - recordDate.current &lt; 100) { return; } // 用户有可能回撤后重新操作，所以这里要在用户操作完后重新初始化记录 recordRef.current = recordRef.current.slice(0, editIndex.current) recordDate.current = Date.now(); recordRef.current.push(stroke); editIndex.current += 1; });}, []) 记录好用户的操作路径后，我只需要对画布进行重新绘制即可。 关闭画布内容 关闭录制，防止重复记录 根据用户操作索引与记录数组，筛选出本次绘制的数据 重新执行绘制内容 执行完毕开启录制按照上述五步，先抽离一个公共方法，根据操作数据进行绘制处理，代码如下：1234567891011121314151617181920212223const handleReDraw = (reDrawData, isClear = true) =&gt; { const ctx = sketchpadRef.current; isClear &amp;&amp; ctx.clear(); ctx.recordStrokes = false; reDrawData.forEach(stroke =&gt; { ctx.mode = stroke.mode; ctx.weight = stroke.weight; ctx.smoothing = stroke.smoothing; ctx.color = stroke.color; ctx.adaptiveStroke = stroke.adaptiveStroke; const points = stroke.segments.slice(); const firstPoint = points.shift().point; ctx.beginStroke(firstPoint.x, firstPoint.y); let prevPoint = firstPoint; while (points.length &gt; 0) { const point = points.shift(); const { x, y } = ctx.draw(point.point.x, point.point.y, prevPoint.x, prevPoint.y); prevPoint = { x, y }; } ctx.endStroke(prevPoint.x, prevPoint.y); }); ctx.recordStrokes = true;} 针对回撤，需要做到以下几步 根据用户操作记录与操作index，筛选出需要绘制的记录。 将操作索引减一。 清空当前画布，根据筛选的内容重新绘制123456789const handleUndo = () =&gt; { if (editIndex.current &lt;= 0) { return; } editIndex.current -= 1; const reDrawData = recordRef.current.slice(0, editIndex.current); handleReDraw(reDrawData)} 针对下一步，操作会相对简单 根据索引获取到下一步的操作数据 操作索引加一 根据下一步的数据进行绘制，这里仅需绘制一步，无需情况画布12345678const handleNext = () =&gt; { if (recordRef.current.length === editIndex.current) { return; } const reDrawData = recordRef.current.slice(editIndex.current, editIndex.current + 1); editIndex.current += 1; handleReDraw(reDrawData, false)} 操作面板的效果如下： 最后，实现导出图片功能，可以直接使用 canvas 的导出能力： 1234567const handleExport = () =&gt; { const dataURL = canvasRef.current.toDataURL('image/png'); const link = document.createElement('a'); link.href = dataURL; link.download = 'canvas_image.png'; link.click();} 至此，完整的画板功能实现完毕。 总结通过本文的介绍，相信大家已经对 Atrament 这个用于 HTML 画布绘制和手写的小型 JS 库有了全面的了解。我们从基本的库介绍、创建画布开始，逐步讲解了如何在 React 项目中实现丰富的编辑功能，包括设置背景、调整画笔属性、使用橡皮擦以及记录用户操作进行撤销和重做。此外，还介绍了如何导出绘制的图片。 通过实例代码和图示，读者可以轻松跟随步骤实现一个功能丰富的画板应用。Atrament 的简单集成和强大功能使其成为处理在线绘图和签名等场景的理想选择。 最后附上笔者的作品","link":"/2024/05/29/base/draw-image/"},{"title":"掌握 Git Rebase：提升代码管理效率的终极指南！","text":"前言在早期使用 git rebase 时，我常常带着一丝抵触情绪。这主要是因为我对 rebase 的理解不够深入，再加上一些操作失误，导致在合并远程代码时经常引发连续的冲突，需要反复解决同一个问题。这种情况逐渐让我放弃了使用 rebase。然而，在团队中，有些同事更偏向于使用合并（merge），而另一些则坚持使用 rebase。一次通过提交历史回溯问题的经历让我意识到，混合使用 merge 和 rebase 会使整个提交树看起来杂乱不堪，现在是时候正视并深入理解 rebase 命令了。 理解 rebase 命令官方文档对 rebase 介绍是：”在另一个基础提示之上重新应用提交内容“。 这段话听起来还是挺抽象的，可以通俗的理解为：「将分支的基础从一个提交改成另一个提交，使其看起来就像是从另一个提交中创建了分支一样」。 我们以最常使用的git rebase [branch]命令为例： 12345678# 1. 主分支为 master，A 同学从 master 切出分支 feat，进行需求开发。git checkout -b feat# 2. B 同学从 master 切出分支 bugfix，进行问题修复。git checkout bugfix# 3. B 同学开发完成，新增 commit B，并合入 master。git merge bugfix# 4. A 同学本地开发产生了两个 commit C 与 commit D，为了减少冲突，执行 rebase 同步 mastergit rebase master 执行完成，git 的提交历史会变成： 从上图的演示可以看到，当执行 rebase 操作时，git 的具体操作如下 寻找共同基点： Git 首先查找 feat 分支和 master 分支的最近共同祖先。这是两个分支分叉之前的最后一个提交，即 first commit。 重放提交： Git 将 feat 分支上从共同基点之后的所有提交（这里是 commit C 和 commit D）暂时保存为补丁（patches），然后将 feat 分支重置到 master 分支的当前头部（这里是 commit B）。 应用补丁： 接下来，Git 依次将之前保存的每个补丁（commit C 和 commit D）应用到 master 分支的新头部（commit B）之上。如果在应用某个补丁时发生冲突，Git 会暂停重放操作并要求您解决冲突。解决后，您需要用 git add 标记解决的文件，并用 git rebase --continue 继续重放操作。 完成 Rebase： 一旦所有补丁都被成功应用，rebase 操作完成。此时，feat 分支的头部将指向应用了 commit C 和 commit D 的新提交，这些提交现在位于 commit B 之后。 rebase 的主要用途rebase主要用于优化提交历史的管理和整合。通过将一个分支的更改重新应用到另一个分支的顶端，我们使用的场景，通常是在本地开发的分支，同步远程最新的代码，使用git rebase [远程分支] 合并代码有以下优点 清晰的历史线索：rebase 通过重新排列提交，使得项目历史呈现出一条清晰的直线，方便理解和追踪。 避免多余的合并提交：使用 rebase 可以避免在合并时产生的多余合并提交，历史记录更为整洁。 交互式编辑提交：git rebase 的交互模式允许开发者合并提交、修改提交信息或调整提交顺序，有助于保持提交历史的清晰和专注。 在处理代码合并时，merge 也可以完成对应的操作，那么二者的区别是什么呢？还是以上面的例子为例，对比一下 merge 与 rebase 后，git 提交历史图 git merge git rebase 可以看到，使用 rebase 方法形成的提交历史是完全线性的，同时相比 merge 方法少了一次 merge 提交，看上去更加整洁。 不同的平台在处理 MR 合并时，虽然执行的是 git merge，但是不同的配置选项，会有不同的效果 附：关于 github 处理 merge 的几个选项 Merge Commit：这是 GitHub 默认的合并方式。使用这种策略时，所有来自特性分支的提交会被保留，并在目标分支上创建一个新的合并提交。这个合并提交有两个父提交，一个是目标分支的当前提交，另一个是特性分支的最后提交。 Squash and Merge：将特性分支的所有提交压缩成一个单独的提交，并将这个提交添加到目标分支上。这种方式不会创建一个实际的合并提交，因此在目标分支的历史中看不到特性分支的存在。 Rebase and Merge：首先将特性分支上的所有提交变基到目标分支的头部，然后再将这些提交直接添加到目标分支上，不创建合并提交。 rebase 高阶操作除了简单的 git rebase [branch] 外，git rebase 还有着许多参数，如： 12345git rebase [-i | --interactive] [&lt;选项&gt;] [--exec &lt;命令&gt;] [--onto &lt;新基础&gt; | --keep-base] [&lt;上游仓库&gt; [&lt;分支&gt;]]git rebase [-i | --interactive] [&lt;选项&gt;] [--exec &lt;命令&gt;] [--onto &lt;新基础&gt;] --root [&lt;分支&gt;] 以下是各个参数的简要介绍，详细文档请👉🏻点击查看 参数 简要介绍 -i 交互式的重写提交历史 –exec 这个选项允许你在每次 rebase 过程中的每个提交上运行一个或多个命令，一般与其它命令组合使用 –onto 允许你将指定的提交从一个分支变基到另一个不同的基点 –keep-base 用于在变基时保持原有基点不变，重新应用分支上的提交。 接下来将会以实际的场景，介绍如何使用这些命令 重写提交历史我们前面提到， rebase 是「在另一个基端之上重新应用提交」，而在重新应用的过程中，这些提交会被重新创建，自然也可以进行修改。在 rebase 的标准模式下，当前工作分支的提交会被直接应用到传入分支的顶端；那如果我们想要对提交历史做自定义的修改，比如移除某个 commit，合并几个 commit，调整 commit 的顺序等。使用git rebase [branch] -i，进入交互式的界面，重写提交历史。 举个🌰 从 master 的 first commit 切出分支 feat。 在 feat 上新增了 commit A、 commit B、commit C 、commit D。 master上新增了 、commit E与commit F 执行完成上述三步，git 提交历史如下 我们希望将 C 的改动剔除，AB 改动合并为 A + B，并且将 D 的改动放置在最前面，改完之后的效果是：first commit -&gt; E -&gt; F -&gt; D -&gt; A+B 切换至 feat 分支，使用 git rebase master -i 进入交互页面 1234567891011121314pick 8bbb2d4 commit Apick 3b08b6c commit Bpick 971f24d commit Cpick ce5d845 commit D# 以下是注释，我们只需操作上面的内容即可# p, pick &lt;提交&gt; = 使用提交# r, reword &lt;提交&gt; = 使用提交，但修改提交说明# e, edit &lt;提交&gt; = 使用提交，进入 shell 以便进行提交修补# s, squash &lt;提交&gt; = 使用提交，但融合到前一个提交# f, fixup &lt;提交&gt; = 类似于 &quot;squash&quot;，但丢弃提交说明日志# x, exec &lt;命令&gt; = 使用 shell 运行命令（此行剩余部分）# b, break = 在此处停止（使用 'git rebase --continue' 继续变基）# d, drop &lt;提交&gt; = 删除提交# 按照我们的诉求，只需要这么修改就可以完成我们的诉求。 1234pick ce5d845 commit Dpick 8bbb2d4 commit Asquash 3b08b6c commit Bdrop 971f24d commit C 使用 squash 会在处理完后，让用户填写新的 commit 信息，执行git log 查看一下 commit 记录: 合并校验在上述合并的例子中，我想要确保调整完成的每次 commit 都能搞符合我们的lint 规范，那么我可以怎么做呢？ 我们还是以上面的例子为例。我们可以在每次处理完成加上exec ‘命令’，就可以 1git rebase master -i --exec &quot;echo '执行 echo 命令了'&quot; 执行完成进入交互页面，原先的代码就会变成这样： 12345678pick 07a3823 commit Dexec echo '执行 echo 命令了'pick eb44384 commit A + commitBexec echo '执行 echo 命令了'pick 230ff64 commit Hexec echo '执行 echo 命令了'pick 91d9a1b commit H-1exec echo '执行 echo 命令了' 同样的，你也可以执行git rebase master -i 进入交互界面后，手动添加 exec 命令。这个指令非常适用于自动化测试或代码检查。 冲突解决当在出现冲突后，git rebase 将会被中断，以下是几种冲突的方式： 1git rebase (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch) git rebase –continue当你在 rebase 过程中遇到冲突后，解决完所有冲突并且用 git add 命令标记解决后，使用 git rebase --continue 来继续之前中断的 rebase 操作。这个命令会尝试继续应用剩余的提交。 git rebase –skip出现冲突后，当你不想包含这个特定的提交，可以使用 git rebase --skip 跳过这个提交。这通常用于放弃某个提交所引入的更改。 举个例子：在使用 rebase 前，大家的状态如下所示，其中 A 与 B、C 都存在冲突，在 feat 执行 git rebase master 12master: first -&gt; Afeat: first -&gt; B -&gt; C git 切换至 commit A，逐个与 commit B commit C 进行合并 处理 commit B 出现冲突，执行 git rebase --skip，会使用 commit A 的内容覆盖 commit B 继续处理 commit C，出现冲突，修改完成，执行 git rebase --continue。 执行完成后，大家的提交历史变为如下，其中 commit B 被丢弃。 12master: first -&gt; Afeat: first -&gt; A -&gt; C git rebase --abort如果你想完全停止 rebase 过程，并将仓库恢复到 rebase 开始前的状态，可以使用 git rebase --abort。这是在遇到复杂问题时回到安全状态的一种方式。 git rebase --quitgit rebase --quit 会退出 rebase 过程，但不会恢复到 rebase 开始前的状态。这将会留下您在中途已经完成的部分操作。 git rebase --edit-todo这个命令允许你在交互式 rebase 过程中编辑还未执行的操作列表。它在更复杂的 rebase 操作中非常有用，比如您需要修改提交的顺序，删除某些提交，或改变提交的方式（比如从 pick 改为 squash）。 我们还是以上面的例子为例，在执行rebase 前大家的提交记录如下： 12master: first -&gt; Afeat: first -&gt; B -&gt; C 在 feat 分支执行 git rebase master。会进入冲突处理。此时运行，git rebase –edit-todo，会进入交互界面，由于只剩下 commit C 未做处理，所以交互页面只剩下 commit C 信息，界面如下： 1pick 8bbb2d4 commit C 我们将 pick 改为 squash，那么 commit B 与 commit C 会在处理完成后进行合并。执行完成后，提交历史会变为： 12master: first -&gt; Afeat: first -&gt; A -&gt; B+C git rebase --show-current-patch当你在解决 rebase 过程中的冲突时，git rebase --show-current-patch 命令可以显示当前正在应用的提交的补丁。这对于理解当前处理的提交更改非常有帮助。效果如下 历史还原在交互式模式下进行 rebase 并对提交执行 squash 或 drop 等命令，或者处理冲突时使用 –skip，会将一些已经存在的 commit 在 git log 中直接删除提交。 那当我们操作失误之后，想要查找这些已经被移除的 commit 该如何处理呢？ 细心的同学可能已经发现，当之前 rebase 的时候，git 并不是直接在原有 commit 基础上进行修改，而是创建了新的 commit。 那如何能够找到历史提交的信息呢？ 这时，我们可以借助 git reflog 来查找和恢复这些历史提交。 Reflogs 是 Git 中用来记录本地仓库分支顶端更新的一种机制。它会跟踪所有分支顶端曾经指向过的提交，因此，reflogs 允许我们找到并切换到当前没有被任何分支或标签引用的提交。 每当分支顶端因为切换分支、拉取新变更、重写历史或添加新提交而更新时，Git 会在 reflogs 中添加一条新记录。这样一来，我们在本地创建的每一次提交都会被记录在 reflogs 中。即使在重写提交历史之后，reflogs 也会包含关于分支旧状态的信息，并允许我们在需要时恢复到该状态。 需要注意的是，reflogs 并非永久保存记录，它们通常会在 90 天后过期并自动删除。 通过执行 git reflog，你将可以看到你的所有 commit 记录。 可以根据 commit id 将 git 重新执行某个commit，例如：git reset --hard commitId 关于rebase 的讨论可以注意到，rebase 的操作看上去相较于merge，确实比较整洁，但本质上是做了历史改写。且本该存在的一次merge操作，也被隐藏掉了，虽然这样可以使 rebase 的提交历史看起来更整洁，但也可能掩盖掉原始开发过程中的重要上下文信息。且 rebase 的操作更为复杂，对于新手不够友好。至于是否采用 rebase，更多的还是应该遵循团队的规范。 切莫在开发时 merge 与 rebase 混和使用，这样极易造成代码冲突 参考文献 https://git-school.github.io/visualizing-git/#free https://git-scm.com/docs/git-rebase/zh_HANS-CN","link":"/2024/07/12/base/git-rebase/"},{"title":"H5 埋点指北","text":"背景在日常的开发过程中，作为前端的 RD 同学，会经常的去配合 PM 去做一些业务埋点，而且有些埋点还贼复杂，埋点完成还要验收，对于 QA 跟 RD 来说都是一件很麻烦的事。 分析痛点 埋点入侵了业务代码 123456// 这里有两个问题：1. 入侵了业务 2. 如果 clickReport 报错了，会影响正常的业务代码const handleClick = () =&gt; { clickReport(); doSomething();} 携带业务参数过多，在组件间需要重复传递 123456789// 层层传递无形之中增加了组件的复杂度const Main = () =&gt; { const baseAnalytics = { city: 1, user: 2 }; return ( &lt;div&gt; &lt;Child1 baseAnalytics={baseAnalytics} /&gt; &lt;Child2 baseAnalytics={baseAnalytics} /&gt; &lt;/div&gt;} 部分复杂的埋点，需要在业务层面做很多额外的操作 目标 减少对业务的入侵 简化埋点的过程 方案 将埋点上报抽象出来埋点的上报必然跟某个dom节点有关联，比如这个节点曝光了，或者这个节点被点击了。我们如果将我们的信息有规律的放在dom节点里，比如约公共的参数在上层，这样我们只要得到需要上报的节点，在一层一层的向上层查找，就可以将我们的数据聚合，并上报了 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const mergeLab = (parentLab: any, childLab: any) =&gt; { if (!parentLab) { return childLab; } if (!childLab) { return parentLab; } return { ...parentLab, ...childLab };};// 只支持 曝光 跟 点击 an 为 analytics 简称export const findAnLabAndReport = ( ele: HTMLElement | null, anData: any, eventType = &quot;click&quot;, anReport) =&gt; { const eventTypeId = eventType === &quot;click&quot; ? &quot;anClickId&quot; : &quot;anViewId&quot;; // 查找到 body 算结束 if (!ele || ele === document.body) { if (!anData.eventId || anData.eventId === &quot;null&quot;) { return; } anReport(anData); return; } const data: any = ele.dataset || {}; let newLab: any; let newEventId: string | undefined = anData.eventId; let newPageId: string | undefined = anData.pageId; if (data.anLab) { try { newLab = JSON.parse(data.anLab); } catch (e) { console.error(e); } } if (!anData.eventId &amp;&amp; data[eventTypeId]) { newEventId = data[eventTypeId]; } if (!anData.pageId &amp;&amp; data.pageId) { newPageId = data.pageId; } findAnLabAndReport( ele.parentElement, { eventId: newEventId, pageId: newPageId, anLab: mergeLab(newLab, anData.anLab) }, eventType, anReport );}; 处理点击事件上报 利用事件冒泡机制，在body上面绑定点击事件，再从event对象中拿到触发点击的节点，将其传递给 findAnLabAndReport即可，这样我们就不在需要再业务代码中增加 clickReport 这样的方法了。 注意：如果click事件被阻止冒泡了，这里就需要手动上传一下 实现效果 1234567891011121314151617181920212223242526document.body.addEventListener( 'click', (e: any) =&gt; findAnLabAndReport(e.target, {}, 'click', clickReport),);const APP = () =&gt; { return ( &lt;div data-page-id=&quot;PageId&quot; data-an-lab={JSON.stringify({ userid: -1, cityid: -1 })} &gt; &lt;ChildA /&gt; &lt;/div&gt; );};const ChildA = () =&gt; { return ( &lt;div data-an-click-id=&quot;ClickId&quot; data-an-lab={JSON.stringify({ id: 1, cityid: 2 })} &gt; ChildA Click &lt;/div&gt; );}; 处理曝光事件利用 intersection-observer 去做埋点曝光，核心还是要将处理的节点传递给我们的 findAnLabAndReport，拿到节点信息后，再将数据一层层聚拢，上报 123456789101112131415161718192021222324252627282930313233343536373839const viewReportInit = ( domOrDomList: HTMLElement | Array&lt;HTMLElement&gt;, viewReport, startObserver = true,): Boolean =&gt; { if (!domOrDomList || (domOrDomList instanceof Array &amp;&amp; !domOrDomList.length) || !startObserver) { return false; } let listerCount = domOrDomList instanceof Array ? domOrDomList.length : 1; const io = new IntersectionObserver( (IntersectionObserverEntryList: Array&lt;IntersectionObserverEntry&gt;) =&gt; { IntersectionObserverEntryList.forEach( (IntersectionObserverEntry: IntersectionObserverEntry) =&gt; { if (IntersectionObserverEntry.isIntersecting) { const targetEle = IntersectionObserverEntry.target; io.unobserve(targetEle); listerCount -= 1; findAnLabAndReport(targetEle as HTMLElement, {}, 'view', viewReport); if (listerCount &lt;= 0) { io.disconnect(); } } }, ); }, ); if (domOrDomList instanceof Array) { domOrDomList.forEach((ele: HTMLElement) =&gt; { io.observe(ele); }); } else { io.observe(domOrDomList); } return true;}; 实现效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const APP = () =&gt; { // 这里只执行一次，如果有依赖的需要执行多次的话，`会出现多次曝光` useEffect(() =&gt; { viewReportInit( Array.prototype.slice.call( document.querySelectorAll(&quot;.view-observer&quot;) || [] ), data =&gt; console.log(data) ); }, []); return ( &lt;div data-page-id=&quot;PageId&quot; data-an-lab={JSON.stringify({ userid: -1, cityid: -1 })} &gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;/div&gt; );};const ChildA = () =&gt; { return ( &lt;div className=&quot;view-observer&quot; style={{ height: &quot;200px&quot;, backgroundColor: &quot;#f0f0f0&quot; }} data-an-view-id=&quot;viewIdA&quot; data-an-lab={JSON.stringify({ id: 1, cityid: 2 })} &gt; ChildA &lt;/div&gt; );};const ChildB = () =&gt; { return ( &lt;div className=&quot;view-observer&quot; style={{ height: &quot;200px&quot;, backgroundColor: &quot;#red&quot; }} data-an-view-id=&quot;viewIdB&quot; data-an-lab={JSON.stringify({ id: 2, cityid: 3 })} &gt; ChildB &lt;/div&gt; );}; 总结笔者这里只是抛转引玉，具体的业务埋点可以根据自己的业务需求去定制，这里主要是想将埋点与业务代码去解耦，不再对业务代码造成严重的入侵，并且简化埋点的方式。可以根据上面提供的核心方法 findAnLabAndReport 去做更多的业务定制，比如笔者在业务开发中，定制了 useObserver 这样一个 hook 去做曝光节点。 点击查看代码地址","link":"/2020/04/09/base/h5-report/"},{"title":"前端模块化原理","text":"前言本文会从前端模块化的演进历史，来逐个分析不同的模块化规范的特性与实现原理，希望通过本文的学习，大家能够彻底弄懂前端模块化的实现原理。看完本文可以掌握，以下几个方面： 为什么需要模块化，什么是模块化。 CommonJS规范的实现原理与加载原理 ESModule 实现原理与加载原理 混乱的前端时期早期在没有打包工具的情况下，很多情况下大家会直接在对应的文件下申明变量与引入依赖，从而造成一些变量污染和依赖引用混乱的问题，线上也会出现一些神奇的 bug。比如 1234var name = 'this is index.js';var outPutMyName = () =&gt; { console.log(name);} 1var name = 'this is home.js'; 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./home.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // outputMyName 不仅可以调用，还会输出 this is home.js outputMyName(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 随着前端项目的复杂度越来越高，从早期的 100 行的脚本变成成千上万行脚本，这种变量污染与依赖引用混乱的问题极大的制约了前端开发的效率，从而前端的模块化开发方案应运而生。 什么是模块化模块化就是将一个复杂的程序依据一定的规则或者说是规范，将其封装成几个单独的块（这里的块指的就是文件），在使用的时候将其组合在一起。 块内部的数据是私有的，只是向外部暴露一些接口或者说是一些方法，让其与其他模块进行通信。 由于在早期社区各个大佬的思路各不统一，先先后后出现了不少模块化的解决方案，这里我们讲一下几个使用比较广泛的模块化规范 CommonJSCommonJS 是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS规范。Node 是 CommonJS在服务器端一个具有代表性的实现。正是因为Node中对CommonJS进行了支持和实现，所以它具备以下几个特点： 在 commonjs 中每一个 js 文件都是一个单独的模块，我们可以称之为 module； 该模块中，包含CommonJS规范的核心变量: exports、module.exports、require exports 和 module.exports 可以负责对模块中的内容进行导出； require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容； 简单使用1234567891011121314151617// 文件 name.jsconst name = 'this is index.js'const outputName = () =&gt; { console.log(name);}module.exports = { outputName,}// 文件 index.jsconst { outputName } = require('./name.js');const main = () =&gt; { console.log('this is index.js'); outputName();}exports = main; 那么它是如何解决变量污染的问题的？module、exports、require 又是如何工作的呢？ 实现原理细心的同学已经发现，在每一个文件中 module、exports、require 是没有经过定义的，按照 JS 的执行逻辑，未定义的变量会直接报错，那么为什么在 Node 的 CommonJS 中可以直接使用呢？因为在实际的编译过程中，实际 Commonjs 对 js 的代码块进行了首尾包装，以我们上面的代码为例，实际的效果是这样的 12345678(function(exports,require,module){ const { outputName } = require('name.js'); const main = () =&gt; { console.log('this is index.js'); outputName(); } exports = main;}) 到这里我们就解答了第一个问题，commonJS 是如何解决变量污染的问题。在 JS 中，函数在执行的过程中会创建自己的私有作用域，外部是无法访问的（这也是我们常说的 JS 闭包），所以就不会存在文章最开始的不同文件加载，导致同一个变量被污染。在 Node 实际的运行过程中，读取到的一个文件只是一个字符串，那么我们还需要运行当前的字符串，所以在函数包装的本质是会有一个 wrapper 函数进行统一的包装处理 12345function wrapper (script) { return '(function (exports, require, module) {' + script + '\\n})'} 对应到上面的代码，实际的执行效果就是 12345678910const moduleFunctionStr = wrapper(` const { outputName } = require('./name.js'); const main = () =&gt; { console.log('this is index.js'); outputName(); } exports = main;`);// 实际的情况并不是简单的 evaleval(moduleFunction)(module.exports, require, module) require 工作机制通过上面的原理分析，我们知道 module、exports、require 是被注入进来的函数。其中 require 函数接收一个变量，返回值为 module.exports 的值。那么我们就可以简单的设计一下 require 函数 1234567891011const require = (id) =&gt; { // id 拿到的可能是相对路径，也有可能是node_modules的依赖，也有可能是 node 的基础模块、根据不同的情况读取到不同的地址ID，确保唯一性 const realId = formatIdToPath(id); const fileStr = getFileStr(realId); const modlue = { exports: {}; }; wrapper(fileStr)(module.exports, require, module); return modlue.exports;} 简单来说，就是读取到对应的代码，通过上诉的 wrapper 包装一下，并且用我们申明好的 module 与 require 注入，利用引用数据类型的特性将执行后的返回值返回。但是这里有一个明显的问题，文件会被反复读取，这样会造成性能的极大浪费，那不妨我们再加一层缓存，在上诉代码基础上稍作改动。 123456789101112131415161718const Module = { cache: {},}const require = (id) =&gt; { // id 拿到的可能是相对路径，也有可能是node_modules的依赖，也有可能是 node 的基础模块、根据不同的情况读取到不同的地址ID，确保唯一性 const realId = formatIdToPath(id); if (Module.cache[id]) { return Module.cache[id].exports; } const fileStr = getFileStr(realId); const modlue = { exports: {}; }; Module.cache[id] = module; wrapper(fileStr)(module.exports, require, module); return modlue.exports;} 现在我们来总结一下 require 的工作流 require 会接收一个参数——文件标识符，通过这个标识符号从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。 如果没有缓存，会创建一个 module 对象，缓存到 Module,(注意，这里会提前缓存一个空数据，解决循环引用带来的)，然后执行文件，加载完文件。 模块导出就是 return 这个变量。其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址, 这与下面要讲的 ESmodule 存在一定的差异，下面会细说。 exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。 exports 和 module.exports通过上面的分析，我们可以知道 exports 其实就是 module 上面的一个属性，且 exports 会被初始化为一个空对象。下面简单列一下二者的使用场景 123456789// module.exportsmodule.exports = function() { ... }module.exports = { name: '张三', say: () =&gt; { ... }}// exportsexports.name = '张三';exports.say = () =&gt; {} 那么问题来了？既然有了 exports，为何又出了 module.exports? 如果我们不想在 commonjs 中导出对象，而是只导出一个类或者一个函数再或者其他属性的情况，那么 module.exports 就更方便了，如上我们知道 exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性，但是我们可以通过 module.exports 自定义导出出对象外的其他类型元素。且 exports 是没法像 module.exports 直接导出一个对象的。比如 12345678// a.jsexports = { x: 1,}// b.jsvar a = require('./a');console.log(a); // 输出 {} ESmoduleNodejs 借鉴了 Commonjs 实现了模块化 (Node v13.2.0 起开始正式支持 ES Modules 特性)，虽然我们可以通过各种构建工具，将 CommonJS 的模块化方案应用到 web 端，但 CommonJS 并不是 javaScript 官方的模块化规范，直到 ES6 的出现，JavaScript 才真正意义上有自己的模块化规范：ESmodule。 ESmodule 的出发点与 CommonJS 有一些不同，它除了提供模块化的解决方案外，更注重代码的静态分析能力，毕竟在 web 端 JS Bundle 的体积会直接影响页面访问速度。所以 ESmodule 相对 CommonJS 有很多优势，比如 借助 ESmodule 的静态导入导出的优势，能够很方便的实现 tree shaking。 现代浏览器可以直接支持ESmodule代码（Vite 就是利用了一特性） 简单使用12345678export const count = 1;export const name = '张三';const age = 12;export { age };export default () =&gt; { console.log(cont);}export * from 'module' // 将module 中的内容导出，但是不包含 default 12import consoleCount, { count, name as homeName, age } from './home.js'import * as homeData from './home.js'; 整体来说 ESmodule 具有以下几个特点 静态语法 ES6 module 的引入和导出是静态的，import 会自动提升到代码的顶层 ，import , export 不能放在块级作用域或条件语句中。这种静态语法，在编译过程中确定了导入和导出的关系，所以更方便去查找依赖，更方便去 tree shaking (摇树) ， 可以使用 lint 工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查。 执行特性 ES6 module 和 Common.js 一样，对于相同的 js 文件，会保存静态属性。但是与 Common.js 不同的是 ，CommonJS 模块同步加载并执行模块文件，ES6 模块提前加载并执行模块文件，ES6 模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历，执行顺序是子 -&gt; 父。 1234567891011121314151617// main.jsconsole.log('main.js开始执行')import say from './a'import say1 from './b'console.log('main.js执行完毕')// a.jsimport b from './b'console.log('a模块加载')export default function say (){ console.log('hello , world')}// b.jsconsole.log('b模块加载')export default function sayhello(){ console.log('hello,world')} 执行 main.js 会输出 1234b模块加载a模块加载main.js开始执行main.js执行完毕 相同的代码，我们用 CommonJS 实现 1234567891011// main.jsconsole.log('main.js开始执行')const a = require('./a');const b = require('./b');console.log('main.js执行完毕')// a.jsrequire('./b')console.log('a模块加载')// b.jsconsole.log('b模块加载') 执行 main 会输出 1234main.js开始执行b模块加载a模块加载main.js执行完毕 只读属性 12import { num , addNumber } from './a'num = 2 // 报错，导入变量是只读的 但是如果是引用数据类型，其实是可以改变其属性，并且会影响所有引用的地方。但是：千万别做么做！！！ 123456789101112// a.jsexport const obj = { x: 1}// b.jsimport obj from './a.js';obj.x = 2;// main.jsimport { obj } from './a.js';import './b.js'console.log(obj); // 输出 { x: 2 } 属性绑定 ESmodule 中则是值的动态映射，并且这个映射是只读的。这与CommonJS 值拷贝是不一样的。比如 123456789101112// a.jsexport var count = 0;export default () =&gt; { count += 1;};// main.jsimport addCount, { count } from './a'console.log(count); // 0addCount();console.log(count); // 1 同样的代码我们拿 CommonJS 实现一遍 1234567891011121314// a.jsvar count = 0;module.exports = { count, addCount: () =&gt; { count += 1; }}// main.jsconst { count, addCount } require('./a')console.log(count); // 0addCount();console.log(count); // 0 实现原理通过上面的分析我们简单总结一下 ESmodule 的特性 使用 import 被导入的模块运行在严格模式下。 使用 import 被导入的变量是只读的，可以理解默认为 const 装饰，无法被赋值 使用 import 被导入的变量是与原变量绑定/引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递。 那如果由我们设计这样的模块化方案，我们应该怎么设计呢 ？我们可以通过 webpack 的产物来窥探其中的秘密。 首先，我们可以用 webpack 搭建一个简单的项目。 12345678910111213// a.jsconsole.log('加载a 文件');export const data = 'aaa';export default function () { console.log(data);}// index.jsconsole.log('开始加载主入口');import sayData, { data } from './modules/a'sayData()console.log(data);console.log('结束加载主入口'); 我们通过上面的分析，可以知道处理 ESmodule 其实是分了两步，第一步是预处理阶段，静态分析依赖编译，第二步是执行阶段。通过编译上诉的代码，在bundle 里面的表现为 12345678910111213141516171819202122232425(() =&gt; { var __webpack_modules__ = ({ &quot;./src/index.js&quot;: ((module, __webpack_exports__, __webpack_require__) =&gt; { // 这里是通过引用调用与 CommonJS 的差异点就在这里 var _modules_a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/a */ &quot;./src/modules/a.js&quot;); console.log('开始加载主入口'); (0,_modules_a__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;])(); console.log(_modules_a__WEBPACK_IMPORTED_MODULE_0__.data); console.log('结束加载主入口'); }), &quot;./src/modules/a.js&quot;: ((module, __webpack_exports__, __webpack_require__) =&gt; { __webpack_require__.d(__webpack_exports__, { &quot;data&quot;: () =&gt; (/* binding */ data), &quot;default&quot;: () =&gt; (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__) }); console.log('加载a 文件'); const data = 'aaa'; function __WEBPACK_DEFAULT_EXPORT__() { console.log(data); } }), })}) 将代码简化后，我们可以了解到，文件的内容都存储在 webpack_modules_ 这个对象上，文件的引用通过 webpack_require 导入，文件导出通过 webpack_require.d 导出，那么我们接下来分析一下 webpack_require 这个函数的实现。 __webpack_require__与 CommonJS 中的 require 实现类似，同样接收一个id，返回这个id 对应内容的导出内容。其实内部的实现也是类似的 12345678910111213141516171819202122232425262728293031323334353637var __webpack_module_cache__ = {};function __webpack_require__(moduleId) { // Check if module is in cache var cachedModule = __webpack_module_cache__[moduleId]; if (cachedModule !== undefined) { if (cachedModule.error !== undefined) throw cachedModule.error; return cachedModule.exports; } // Create a new module (and put it into the cache) var module = __webpack_module_cache__[moduleId] = { // no module.id needed // no module.loaded needed exports: {} }; // Execute the module function try { // 这里被我修改了，实际的运行要比这个复杂的多 var factory = __webpack_modules__[moduleId]; factory(module, module.exports, __webpack_require__) } catch(e) { module.error = e; throw e; } // Return the exports of the module return module.exports;}__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))__webpack_require__.d = (exports, definition) =&gt; { for(var key in definition) { if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) { // 设置其不可改属性 Object.defineProperty(exports, key, { enumerable: true, get: definition[key] }); } }}; 总结现在我们再来一起回顾一下 CommonJS 与 ESmodule 的一些特性。 CommonJS CommonJS 模块由 JS 运行时实现。 CommonJs 是单个值导出，本质上导出的就是 exports 属性。 CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。 CommonJS 模块同步加载并执行模块文件。 CommonJS 导出是浅拷贝赋值，无法读取到修改后的值。但是可异步获取。 ESmodule ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。 ES6 Module 的值是动态映射的，可以通过导出方法修改，可以直接访问修改结果。 ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。 ES6 模块提前加载并执行模块文件，采用深度优先遍历，执行顺序是子 -&gt; 父。 ES6 Module 导入模块在严格模式下。 ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。 其它模块化规范 AMD AMD是英文Asynchronous Module Definition（异步模块定义）的缩写，它是由JavaScript社区提出的专注于支持浏览器端模块化的标准。从名字就可以看出它与CommonJS和ES6 Module最大的区别在于它加载模块的方式是异步的。下面的例子展示了如何定义一个AMD模块。 12345define('getSum', ['calculator'], function(math) { return function(a, b) { console.log('sum' + calculator.add(a, b)) }}) UMD 严格来说，UMD并不能说是一种模块标准，不如说它是一组模块形式的集合更准确。UMD的全称是Universal Module Definition，也就是通用模块标准，它的目标是使一个模块能运行在各种环境下，不论是CommonJS、AMD，还是非模块化的环境（当时ES6 Module还未被提出）。 123456789101112131415(function(global, main) { // 根据当前环境采取不同的导出方式 if (typeof define === 'function' &amp;&amp; defind.amd) { // AMD define(...) } else if (typeof exports === 'object') { // CommonJS module.exports = ... } else { global.add = ... }})(this, function() { // 定义模块主体 return {...}}) CMD CMD(Common Module Definition - 通用模块定义)规范主要是Sea.js推广中形成的，一个文件就是一个模块，可以像Node.js一般书写模块代码。主要在浏览器中运行，当然也可以在Node.js中运行。 它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。 123456789101112131415161718192021222324252627282930// model1.jsdefine(function (require, exports, module) { console.log('model1 entry'); exports.getHello = function () { return 'model1'; }});// model2.jsdefine(function (require, exports, module) { console.log('model2 entry'); exports.getHello = function () { return 'model2'; }});// main.jsdefine(function(require, exports, module) { var model1 = require('./model1'); //在需要时申明 console.log(model1.getHello()); var model2 = require('./model2'); //在需要时申明 console.log(model2.getHello());});&lt;script src=&quot;https://cdn.bootcss.com/seajs/3.0.3/sea.js&quot;&gt;&lt;/script&gt;&lt;script&gt; seajs.use('./main.js')&lt;/script&gt;// 输出// model1 entry// model1// model2 entry// model2 参考文档 前端模块化详解（CommonJS、AMD、CMD、ES Module） 「Node.js系列」深入浅出Node模块化开发——CommonJS规范 深入 CommonJs 与 ES6 Module 深入浅出 Commonjs 和 Es Module 从构建产物洞悉模块化原理","link":"/2022/12/02/base/module/"},{"title":"Popover 让弹窗变得更简单！","text":"Popover自 2024 年 4 月起，此功能适用于最新设备和浏览器版本。在旧设备或浏览器中，此功能可能无法正常使用。 什么是 PopoverPopover API 提供了一个标准化、统一而又灵活的方法，使开发者能够在网页内容上方轻松展示浮动的弹出内容。这种弹出内容可以通过 HTML 属性进行声明式控制，或通过 JavaScript 进行动态管理，从而为开发者提供操作的灵活性。 只需少量代码即可实现即可快速创建一个弹窗控件。例如，开发者可以简单地添加 HTML 标签和属性来实现一个基础的弹窗，或者使用 JavaScript 添加复杂的交互和动态内容。 12&lt;button popovertarget=&quot;mypopover&quot;&gt;打开弹窗&lt;/button&gt;&lt;div id=&quot;mypopover&quot; popover&gt;弹窗内容&lt;/div&gt; 特点包括： 易于使用：通过 HTML 的 data- 属性或 JavaScript 方法，开发者可以快速创建和配置弹窗。 高度可定制：支持完全自定义弹窗的外观和感觉，包括动画、位置和大小。 无需关心 DOM 位置：Popover 在显示时会自动浮现于最前端，不依赖于在 DOM 中的具体位置，打开时，它会变成一个独立的图层放在”最前端“。 自动适应：支持响应式设计，自动调整以适合不同的屏幕和设备。 交互性强：开发者可以利用 popovertargetaction=&quot;hide&quot; 属性和 ESC 键控制关闭行为，增加用户交互的便捷性。 123456789&lt;button popovertarget=&quot;my-popover&quot; class=&quot;trigger-btn&quot;&gt; 打开弹窗&lt;/button&gt;&lt;div id=&quot;my-popover&quot; popover=manual&gt; &lt;button class=&quot;close-btn&quot; popovertarget=&quot;my-popover&quot; popovertargetaction=&quot;hide&quot;&gt; &lt;span aria-hidden=”true”&gt;❌&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;关闭弹窗&lt;/span&gt; &lt;/button&gt; &lt;p&gt;这里是弹窗内容&lt;p&gt;&lt;/div&gt; 类似的APIPopover 与 dialog API 类似，后者从 2022 年起已被主流浏览器支持。它的使用同样非常直接，不过 dialog 在显示时会默认添加一个背景层，并以独立图层的形式显示在前端。 12345&lt;dialog id=&quot;dialog&quot;&gt; &lt;button id=&quot;closeBtn&quot;&gt;Close&lt;/button&gt; &lt;p&gt;对话框内容&lt;/p&gt;&lt;/dialog&gt;&lt;button id=&quot;btn&quot;&gt;打开对话框&lt;/button&gt; 总结一下Popover API 是一种新的 Web API，从 2024 年 4 月起在最新的设备和浏览器中可用。它允许开发者以最小的代码实现高度可定制的弹出窗口，这些窗口可以通过 HTML 或 JavaScript 控制，并能自动适应在前端显示，不受 DOM 结构的限制。此外，dialog API 与 Popover 在功能上相似，但包含默认背景层，两者都提供了现代 Web 应用中弹窗功能的优雅实现。 更多详细API，可参考 MDN：https://developer.mozilla.org/en-US/docs/Web/API/Popover_API","link":"/2024/05/08/base/popover/"},{"title":"CSS 轻松实现“日间模式”和“夜间模式”","text":"夜间模式作为熬夜专业户，常常会在深夜刷手机。当长时间使用没有【夜间模式】的 APP时，总会感觉到眼睛酸痛。微信就是没有【夜间模式】的代表之一。按照微信的说法：你的夜晚太珍贵，我们不忍心占用，更不愿意成为你半夜醒来看手机的原因。愿你每夜好眠。 对于资深打工人而言，深夜确实太珍贵了！我只有深夜才能放松刷会手机😭。长时间使用亮色系的 APP 是不能接受的。经过一番查阅，iOS 中只需将手机设置为深色模式就可以实现微信的【夜间模式】。 ✿✿ヽ(°▽°)ノ✿ 那问题来了，作为一名前端，我们是否也可以为用户提供自适应的夜间模式？ color-schemecolor-scheme CSS 属性允许元素指示它可以舒适地呈现哪些颜色方案。操作系统颜色方案的常见选择为“亮色”和“暗色”，或“日间模式”和“夜间模式”。当用户选择其中一种颜色方案时，操作系统会对用户界面进行调整，包括表单控件、滚动条和 CSS 系统颜色的使用值。 属性介绍 属性 含义 normal 表示元素未指定任何配色方案，因此应使用浏览器的默认配色方案呈现 light 表示可以使用操作系统亮色配色方案渲染元素 dark 表示可以使用操作系统深色配色方案渲染元素 dark 禁止用户代理覆盖元素的颜色方案。 当没有特殊设置时，color-scheme 会响应系统当前的颜色模式。接下来我们就看看几种实现【夜间模式】的方案吧！ 方式1：通过浏览器的适配色方案实现【亮色】与【暗色】切换通过通过系统颜色 Canvas 与 CanvasText 来自适应响应深夜模式 1234:root { color: CanvasText; background-color: Canvas;} 默认情况下，CanvasText 会生成接近 black 的颜色，而 Canvas 是接近 white 的颜色。实际实现取决于浏览器。 这种方案适合于简单的色系替换，当场景复杂且有色值要求时，该方案不大适合。 方式2：通过媒体查询实现主题切换@media (prefers-color-scheme: dark) 与 @media (prefers-color-scheme: light) 来实现两种模式切换。通过查询的当前采用的模式，来设置不同的颜色。 1234567891011body { background-color: #fff; color: #000}@media (prefers-color-scheme: dark) { body { background-color: #000; color: #fff; }} 该方案灵活性高，但代码量偏大。这里我们可以配合 css 变量来优化一下： 12345678910111213141516:root { --text-color: #000; --bg-color: #fff;}@media (prefers-color-scheme: dark) { :root { --text-color: #fff; --bg-color: #000; }}body { background-color: var(--bg-color); color: var(--text-color)} 通过 css 变量与媒体查询，实现在不同模式下响应不同的主题。 方式3：使用 light-dark 实现主题切换light-dark() 是接受两个参数的函数，且这两个参数都必须为 &lt;color&gt;。系统会根据使用的配色方案选择其中一种。 如果所用配色方案为 light 或未知，则返回第一个值的计算值。 如果使用的配色方案为 dark，则返回第二种颜色的计算值。 light-dark 的实现方式可以将方案 2 的方式得到简化 1234body { background-color: light-dark(#fff， #000); color: light-dark(#fff， #000);} 需要注意的是，light-dark()目前属于比较新的属性，存在一定的兼容性 总结实现“日间模式”和“夜间模式”的三种方式 通过系统配色方案试下：Canvas 与 CanvasText 采用 prefers-color-scheme 媒体查询，根据响应实现不同色系。 使用 light-dark 实现两种模式切换。","link":"/2024/04/14/base/theme/"},{"title":"微信小程序列表埋点曝光指南","text":"背景最近项目中，开发一个小程序列表页，PM大大给我提了一个埋点需求，列表中的每一项，出现在屏幕中的时候，需要上报一条记录。 目标如图中操作，要依次上报 item 1 - item7,但是上滑的时候，不再重复上报 怎么做接到需求的第一感觉是，我难道要监听页面滚动，然后通过offsetTop 去算吗！！！？？？这样显然不是最高效的。于是我去翻了一下微信的开发文档，发现有一个 IntersectionObserver 的API，正好满足我的需求。 首先我们需要创建一个 IntersectionObserverwx.createIntersectionObserver(Object component, Object options) IntersectionObserver 一共有四个方法 IntersectionObserver.relativeTo 使用选择器指定一个节点，作为参照区域之一。 IntersectionObserver.relativeToViewport(Object margins) 指定页面显示区域作为参照区域之一 IntersectionObserver.observeCallback callback) 指定目标节点并开始监听相交状态变化情况 IntersectionObserver.disconnect()停止监听。回调函数将不再触发 我们这里的参照物是屏幕，所以我们使用IntersectionObserver.relativeToViewport来制定我们的参照物，并制定相较规则 1234567891011121314151617181920212223242526272829303132Page({ data: { list: [ { value: 1, hadReport: false }, { value: 2, hadReport: false }, { value: 3, hadReport: false }, { value: 4, hadReport: false }, { value: 5, hadReport: false }, { value: 6, hadReport: false }, { value: 7, hadReport: false }, { value: 8, hadReport: false }, { value: 9, hadReport: false }, ] }, onLoad() { this._observer = this.createIntersectionObserver({ observeAll: true }) this._observer.relativeToViewport({ bottom: 0 }) .observe('.item', (res) =&gt; { const { index } = res.dataset; if (!this.data.list[index].hadReport) { console.log(`report ${index}`) this.data.list[index].hadReport = true; this.setData({ list: [].concat(this.data.list)}) } }) }, onUnload() { if (this._observer) this._observer.disconnect() }}) 最后实现的效果如下 结论 类似这样的埋点，我们以后可以采用监听dom的方式去做，而不是一昧的只想着监听滚动计算位置。 除了可以做埋点上报，这种监听的方式，还是很适合去做一些图片懒加载等一系列操作。 微信小程序代码片段，点击查看 联想上述的所有操作，都是基于微信小程序去做的，那么浏览器有没有相应的API呢？ 浏览器是有相应的API的，Intersection Observer API，具体的用法与上述的用法类似。 123456789var options = { rootMargin: '0px', threshold: 1.0}var observer = new IntersectionObserver((...args) =&gt; { console.log(args);}, options);observer.observe(document.querySelector('.item')); 注意这个会监测dom元素的可见性变化，也就是说当dom出现在视窗的时候会触发回调，消失在视窗的时候也会触发回调 但是浏览器的IntersectionObserver属性兼容性一般，如果想要在浏览器做曝光或者懒加载可以考虑采用原始的方法，监听浏览器滚动，并计算dom的offsetTop，可以参考笔者很久前写的图片延时 加载原理 及应用 参考文档 谈谈IntersectionObserver懒加载 微信小程序IntersectionObserver 文档","link":"/2019/10/14/mini-program/data-report/"},{"title":"深度解析一码多投框架原理","text":"前言本文将会从业务的视角阐述跨端的应用场景，从技术视角分析不同的技术路线的优劣势，同时以 RaxJS 为模板，从多个维度对运行时与编译时两套技术路线的原理做深入分析。阅读完本文，你会有以下收获： 了解跨端的应用场景与技术路线。 了解一个跨端框架的基本原理。 跨端的应用场景在移动互联网时代，流量成为企业获取用户和推动业务增长的核心。公域流量的有效获取尤为关键，例如微信小程序等渠道。然而，公域与私域产品在用户体验上有所不同，私域通常更优。因此，提升公域流量需要改善其用户体验，使之匹配私域的水平。技术上，使用跨端框架可以降低成本，提高开发效率，实现多渠道产品的一致性。这样不仅降低了开发和维护的难度，还能快速应对市场变化，增强竞争力。 跨端框架的技术路线选择跨端框架的两种主要技术路线分别是编译时（Compile-Time）和运行时（Runtime）的技术路线。这两种路线在实现方式、优劣势和适用场景上有一些显著的差异。 编译时方案 优势 劣势 - 性能更优：由于代码在编译时生成原生代码，无需在运行时进行解释，减少了运行时的开销，性能较好，更接近原生应用。 - 编译时语法限制： 在编译时，由于需要提前确定目标端的代码结构，可能会对部分高级语法进行限制，影响一些动态特性的使用。 - 更好的静态分析：编译时方案可以在编译阶段进行静态分析，检测潜在的问题，提前发现并解决一些潜在的错误，有利于代码质量的保证。 - 研发效率影响： 在编译时，于在编译时需要对代码进行额外处理，可能会导致开发效率相对较低，特别是在不熟悉的情况下。 运行时方案 优势 劣势 - 灵活度高：运行时方案更加灵活，能够在运行时根据不同端的环境动态调整代码，支持更丰富的语法和特性。 - 性能相对差： 相比编译时方案，运行时方案通常性能相对较差。由于需要在运行时动态适配不同平台，可能引入一些运行时的性能开销。 - 开发效率高：运行时方案在开发阶段更为友好，能够充分利用原生平台的特性，提高开发效率。 - 潜在的兼容问题： 由于在运行时需要适配不同平台，可能面临一些潜在的兼容性问题，需要在代码中进行一些条件判断和处理。 跨端框实现原理无论是编译时方案，还是运行时方案，一个跨端框架都可以简化抽象为三层：应用层、框架层、构建层 应用层：在跨端框架的应用层，开发者使用一套统一的组件和API进行业务开发。这些组件和API包括诸如View、Text等基础组件，以及与具体业务相关的高级组件。应用层的代码是开发者直接编写的，不需要考虑目标端的差异性。 框架层：框架层作为跨端框架的核心，负责处理应用层代码在不同端的运行差异。它通过提供垫片（Shim）的能力，在运行时抹平多端差异，暴露统一的容器接口。 构建层：构建层是整个跨端框架的底层基础，它通过编译工具将开发者编写的标准 DSL 编译为适应不同端的具体 DSL。这一层的工作包括代码转译、资源管理、性能优化等。 下面我们对以上三层进行逐层分析，了解具体实现原理 应用层无论采用编译时方案还是运行时方案，应用层都需遵循多端一致的核心原则，即制定标准。这一过程首先涉及最上层的 DSL 的选择，通常我们会根据团队的技术现状来进行决策。例如，如果团队主要使用 Vue 技术栈，DSL 层就可以以 Vue 的 DSL 为标准。 在原子组件与 API 标准的制定上，同样需要根据团队的技术现状和业界标准做出明智的决策。一个很好的选择参考，在组件方面，可以采用 React-Native 的组件标准来实现；而在API方面，可以采用微信开放 API 为标准来进行实现。 然而需要注意的是，考虑到性能和包体积的因素，原子组件的 API 可能更适合选择在多端分别用对应端的源码实现。因此，在构建过程中，需要进行按需打包和深度 tree-shaking 处理，以确保最终产品在性能和体积方面都能达到最佳状态。 框架层垫片技术在确保框架一致性方面扮演着关键的角色。通过巧妙运用垫片技术，框架能够在各种不同的终端上模拟出类似的运行环境，有效地遮蔽了底层的差异性。以此为例，对于不同的容器环境，框架层能够提供一致的操作接口，使得开发者能够摆脱对底层实现细节的烦扰。鉴于小程序容器与端内容器、浏览器环境之间的显著差异，垫片技术在小程序环境中发挥着核心的应用作用。值得注意的是，不同的技术路线在框架层的能力存在差异。接下来，我们将以 RaxJS 在微信小程序下为例，对不同技术路线的实现进行深入分析。 我们简单实现一个页面，这个页面包含以下两个功能：1）引用了一个本地组件，其展示内容为父组件传递，且点击后，会通过父组件修改展示内容2）有一个自加器，每点击一次，数字会自动增加一次。先看一下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142// 页面组件import { createElement, useState } from 'rax';import View from 'rax-view';import Text from 'rax-text';import Demo1 from '../../components/Demo1';import styles from './index.module.css';export default function Home() { const [count, setCount] = useState(0); const [txt, setTxt] = useState('hello demo1'); const addCount = () =&gt; { setCount(count + 1); }; const changeTxt = () =&gt; { setTxt(`展示随机数：${Math.random().toFixed(3)}`); }; return ( &lt;View className={styles.homeContainer}&gt; &lt;Demo1 txt={txt} onTxtClick={changeTxt} /&gt; &lt;Text className={styles.homeInfo} onClick={addCount}&gt;{count}&lt;/Text&gt; &lt;/View&gt; );}// Demo1 组件import { createElement } from 'rax';import View from 'rax-view';import Text from 'rax-text';import styles from './index.module.css';export default function Demo1({ txt, onTxtClick }) { return ( &lt;View className={styles.homeContainer}&gt; &lt;Text className={styles.homeInfo} onClick={onTxtClick}&gt;父组件传递{txt}&lt;/Text&gt; &lt;/View&gt; );} 真机表现如下： 小程序 H5 接下来我们分析一下，在编译时与运行时产物（注：代码均为简化后代码） 编译时：对于编译时框架而言，垫片能力会比较轻，更多的是做好 dom 与框架的映射关系微信小程序： Home 页面组件产物 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// JS 产物function Home() { var _useState = (0, _jsx2mpRuntime.useState)(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1]; var _useState3 = (0, _jsx2mpRuntime.useState)('hello demo1'), _useState4 = _slicedToArray(_useState3, 2), txt = _useState4[0], setTxt = _useState4[1]; var changeTxt = function changeTxt() { setTxt(&quot;\\u5C55\\u793A\\u968F\\u673A\\u6570\\uFF1A&quot;.concat(Math.random().toFixed(3))); }; this._updateChildProps(&quot;2&quot;, { &quot;txt&quot;: txt, &quot;onTxtClick&quot;: changeTxt }); this._updateData({ &quot;_d0&quot;: txt, &quot;_d1&quot;: count }); this._updateMethods({ &quot;_e0&quot;: changeTxt, &quot;_e1&quot;: function addCount() { setCount(count + 1); } });}var __def__ = Home;Page((0, _jsx2mpRuntime.createPage)(__def__, { events: [&quot;_e0&quot;, &quot;_e1&quot;]}));// WXML 产物&lt;block wx:if=&quot;{{$ready}}&quot;&gt; &lt;view class=&quot;__rax-view homeContainer&quot;&gt; &lt;c-44b3ce txt=&quot;{{_d0}}&quot; onTxtClick=&quot;_e0&quot; __tagId=&quot;{{__tagId}}-2&quot; /&gt; &lt;text class=&quot;__rax-text homeInfo&quot; bindtap=&quot;_e1&quot;&gt;{{ _d1 }}&lt;/text&gt; &lt;/view&gt;&lt;/block&gt;// JSON 产物{ &quot;usingComponents&quot;: { &quot;c-44b3ce&quot;: &quot;../../components/Demo1/index&quot; }} 组件 Demo1 产物 12345678910111213141516171819202122232425// JS 产物function Demo1(_ref) { var txt = _ref.txt, onTxtClick = _ref.onTxtClick; this._updateData({ &quot;_d0&quot;: txt }); this._updateMethods({ &quot;_e0&quot;: onTxtClick });}var __def__ = Demo1;Component((0, _jsx2mpRuntime.createComponent)(__def__, { events: [&quot;_e0&quot;]}));// WXML 产物&lt;block wx:if=&quot;{{$ready}}&quot;&gt; &lt;view class=&quot;__rax-view homeContainer&quot;&gt; &lt;text class=&quot;__rax-text homeInfo&quot; bindtap=&quot;_e0&quot;&gt;父组件传递{{ _d0 }}&lt;/text&gt; &lt;/view&gt;&lt;/block&gt;// JSON 产物{ &quot;component&quot;: true} 微信小程序对应的页面与组件分别有两个构造器：Page、Component。分别会接受对应构造器的生命周期与基础数据与方法。通过产物看，我们传递给 Page与 Component 的均为 jsx2mpRuntime 所构造的对象。接下来我们会从三个维度去分析垫片的功能。 生命周期映射分析：抹平容器差异。以 Page 为例，通过构造类对象，制定框架生命周期，同时通过事件机制触发多频次生命周期钩子，最后再通过时机映射与微信小程序的 Page 生命周期关联。 逻辑层一致性分析：抹平框架差异。 数据渲染 当页面构造完成后，会触发组件 render，render 本身是执行函数式组件，触发函数内部的 _updateData 方法，_updateData 方法最终会触发 Page 构造器本身的 setData 方法，从而触发页面重新渲染，最终页面呈现。（这里需要注意，实际的渲染是发送了两次，第一次是构造 Page 生命周期，这一次是一个空白渲染，并在渲染完成后会吧，$ready 置为 true。页面配置挂载完成后，会触发 Page 的 onLoad 回调，在 onLoad 回调中会触发函数式组件首次 render，这一次 render 会调用一次 setData 方法，从而渲染真正的页面数据） 事件机制与状态变更 在组件构造时，会将对应的时间挂载到实例上，当点击触发就会调用对应方法，前后数据对比完成后，重新触发render，渲染过程与上述描述一致，只是这次从 hook 中取的值是最新的值。 父子组件通信 通过编译时 tagID 的注入，在父组件 render 的过程中，会通过 _updateChildProps 与子组件关联，从而注入方法，实现父子组件绑定。 UI 层一致性分析：UI 单位样式抹平。 UI 容器样式一致 除了逻辑层的垫片外，还需要保障 CSS 在多端的表现一致。通过上面的分析我们可以知道，在开发过程中，我们会使用原子组件来开发，如 View 组件对应 RN 侧的 VIew 标签，H5 的 Div 标签，微信小程序的 View 标签，通过这一层我们就可以实现容器层的一致。 H5侧 View 容器默认样式 小程序侧 View 容器默认样式 CSS 单位一致 微信小程序支持 rpx 为单位，但是 H5 不支持，我们可以通过构建过程中的单位转换实现一致。以下为：源码、微信小程序、H5 单位转换。 源码 H5 侧表现 小程序侧表现 运行时：对于运行时框架而言，垫片的能力会比较重，需要提供统一的渲染模板，与虚拟dom的处理。Home 页面组件产物 123456789101112131415// JS 产物const render = require('./../../render');function init(window, document) {require('./../../bundle.js')(window, document);}Page(render.createPageConfig('pages/Home/index', [], init, ''))// WXML 产物&lt;import src=&quot;./../../root.wxml&quot;/&gt;&lt;template is=&quot;RAX_TMPL_ROOT_CONTAINER&quot; data=&quot;{{r: root}}&quot; /&gt;// JSON 产物{ &quot;usingComponents&quot;: { &quot;element&quot;: &quot;./../../comp&quot; }} 通用 Comp 产物 12345678910111213// JS 产物const render = require('./render.js');Component(render.createElementConfig());// WXML 产物&lt;import src=&quot;./root.wxml&quot;/&gt;&lt;template is=&quot;RAX_TMPL_ROOT_CONTAINER&quot; data=&quot;{{r: r}}&quot; /&gt; // JSON 产物 { &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;element&quot;: &quot;./comp&quot; }} 构建后产物分析，我们会发现运行时与编译时的产物差别非常大，产物只有一个页面产物，并没有 Demo1 的产物，但是多了一个通用的 Comp 产物与 bundle.js。那么运行时又是如何渲染，如何抹平差异的呢？接下来，我们依然从三个维度来分析整个过程 生命周期映射分析：抹平容器差异以 Page 为例分析，与编译时一样，会通过 render 函数构造出微信小程序的生命周期钩子，但是生命周期的执行函数比编译时要复杂很多，具体的逻辑会在接下来的渲染过程详细分析。 逻辑层一致性分析：抹平框架差异。 数据渲染 通过调用堆栈分析可以看到，运行时也是渲染了两次，第一次为空渲染，第二次在 onLoad 阶段进行渲染，这里的渲染与编译时差别很大，在渲染的过程中，会抽象出一个虚拟Dom，在最后的调用 root.appendChild 时将构造好的节点插入，实际是将虚拟dom更新到整个 data 节点。 再通过微信开发者工具查看组件的数据信息，整个 data 就是一棵 Dom 树 UI 层拿到这颗 Dom 树后，会通过模板进行循环渲染，最后渲染出整个页面。（这里说个题外话：小程序的动态化方案也是可以采取类似的方案，绕过微信审核，动态发版） 事件机制与状态变更 通过事件委托的机制，在生成 Page 实例配置时，将所有的事件进行注册，当通用模板对应节点触发事件时，就会响应到对应的代理事件，代理事件再通过当前触发的节点，去维护的 Dom 树中查找对应的元素及其绑定的事件，从而进行响应，当响应时间触发对应的函数后，调用 setData，修改虚拟 Dom 节点，修改完成后进行页面结构更新。 父子组件通信 通过上述的分析可以知道，因为不存在子组件，本质上父子通信都发生在 JS 的 runtime 阶段，状态变更引起最后的 Dom 树变化，从而导致渲染不同的元素。这里就不再赘述。 阅读至此，或许您已经注意到一个关键点：我们可以在微信小程序中引入 React，并进一步通过保留 React 接口的方式，在微信小程序环境下实现所需的功能，从而创建一个类似于 React-Dom 或 React-Native 的容器框架。通过这种方式，我们能够充分发挥 React 在不同平台下的强大能力，实现对应接口的功能，使其在微信小程序中得以充分展现。Remax 就是一款主打 React 运行时框架，在小程序端，完整的引入了 React 框架。 UI 层一致性分析：UI 单位样式抹平。UI容器与单位的标准化方案与编译时相同，但与编译时不同的是，由于不存在独立的组件文件，所有CSS代码都汇聚在一个文件中。此时的关键问题在于解决CSS权重的问题，通过不同的哈希值可以有效解决权重冲突。 构建层构建层大致的工作流程是，针对不同的容器采用不同的打包工具（如 RN 的metro，web 端的 webpack），将代码编译的对源码进行拆解成符合对应容器的标准文件。在所有容器转换过程中，小程序的转换最为复杂，接下来我们以 RaxJS 小程序的转换过程进行分析，了解其运作流程与转换原理。 编译时通过产物分析，我们发现构建层，将一个 JSX 文件拆分为三个文件：WXML、JS、JSON。同时针对 app.json 也做了对应转换。RaxJS 在小程序端的打包工具采用的是 webpack，让我们看一下，webpack的配置文件（注：配置为精简后配置，只展示了跟小程序转换的核心loader与plugin）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647{ target: 'node', resolve: {...}, module: { rules: [ { test: /\\.(tsx?)$/, use: [{ loader: 'ts-loader/index.js', }] }, { test: /\\.t|jsx?$/, enforce: 'post', use: [ { loader: 'jsx2mp-loader/src/component-loader.js' }, { loader: 'rax-platform-loader/lib/index.js' }, { loader: 'jsx2mp-loader/src/script-loader.js' }, { loader: 'jsx2mp-loader/src/app-loader.js' }, { loader: 'jsx2mp-loader/src/page-loader.js' }] }, { test: /\\.js$/, use: [ { loader: 'jsx2mp-loader/src/script-loader.js' }, ], }, { test: /\\.(bmp|webp|svg|png|webp|jpe?g|gif)$/i, use: [ { loader: 'jsx2mp-loader/src/file-loader.js' } ] }, { test: /\\.json$/, use: [ { loader: 'jsx2mp-loader/src/script-loader.js' }, { loader: 'json-loader/index.js' } ] }, ], }, plugins: [ JSX2MPRuntimePlugin, MiniAppConfigPlugin, ], entry: { app: [ '/Users/pengrongshu/work/doc-demos/rax-example/src/app.ts?role=app', ], '@page@pages/Home/index': [ '/Users/pengrongshu/work/doc-demos/rax-example/src/pages/Home/index?role=page', ], },}; 通过简化后的 webpack 配置分析可以知道，loader 与 plugin 的工作流大致如下： 那么我们以项目维度、页面&amp;组件维度、编译维度，看看 loader 与 plugin 是如何做处理转换的 项目维度项目维度的源码非常简单，对于微信小程序而言，需要 app.js、app.wxss、app.json 三个文件。 123import { runApp, IAppConfig } from 'rax-app';const appConfig: IAppConfig = {};runApp(appConfig); 通过对 loader 执行的分析，app.ts 经过处理后会得到 app.js 与 app.wxss 两个文件，那么 app.json 又是什么时候生成的呢？ MiniAppConfigPlugin 插件会在编译时，对项目的 app.json 与对应小程序的配置容器进行融合处理，最后生成所需的 json 文件 页面&amp;组件维度通过对页面组件的解析，在 page-loader 阶段，完成对页面 page.js、page.json、page.wxml、page.json 四个文件生产。同时通过依赖分析，将 import 的各个依赖，依次进入自己的 loader 处理，直至处理完成。 编译维度通过上述分析，我们可以了解到，无论是组件还是页面，都是通过 loader 进行解析转换，二者在处理过程上区别并不大，核心都是基于 jsx-compiler 整体转换流程大致分为三步： 将jsx解析为三部分：import、export、AST 将上一步解析的内容根据不同的诉求在不同的 module 进行处理 将处理好的内容，生成与容器对应的 JS、WXML、WXSS、JSON 数据 在编译处理完成后，会通过 JSX2MPRuntimePlugin 将运行时垫片引入。通过上述分析，我们可以发现，编译时方案的构建处理的过程非常复杂。这也解释了为什么编译时方案的迭代效率相对较低。实际开发中，开发人员的编码风格千差万别，对应不同的编码风格需要相应的转换。这种多样性难以通过全面枚举来解决，导致多端展示不一致的问题，进而需要进行排查和分析，增加了开发工作量。同时，语法的约束也天然地限制了开发效率。 运行时相较于编译时各种文件转换语法处理，运行时的构建过程相对简单，通过简化后的 webpack 配置文件分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849{ output: { assetModuleFilename: 'assets/[hash][ext][query]', crossOriginLoading: 'anonymous', filename: '[name].js', path: '/Users/pengrongshu/work/doc-demos/rax-example/build/wechat-miniprogram', publicPath: '/', }, module: { rules: [ { test: 'jsx', exclude: [null], use: [ { loader: '@builder/pack/deps/babel-loader/index.js', }, { loader: '/rax-platform-loader/lib/index.js', }, ], }, { test: 'tsx', exclude: [null], use: [ { loader: '/Users/pengrongshu/work/doc-demos/rax-example/node_modules/@builder/pack/deps/babel-loader/index.js', }, { loader: '/Users/pengrongshu/work/doc-demos/rax-example/node_modules/ts-loader/index.js', }, { loader: '/Users/pengrongshu/work/doc-demos/rax-example/node_modules/rax-platform-loader/lib/index.js', }, ], }, ], }, optimization: {}, plugins: [ MiniAppRuntimePlugin, MiniAppConfigPlugin, ], entry: { bundle: ['/Users/pengrongshu/work/doc-demos/rax-example/src/app.ts'], },}; 整体处理过程分为三部分：1）前置编译前生产 app.json；2)编译打包将所有依赖打包生成 bundle.js 3）处理页面，根据页面配置信息生成通用页面文件，组件文件以及项目app.js 等 与编译时的解决方案相比，运行时的方法在构建过程中更为简单，并且整体的 AST 转换与常用的转换工具相比并无太大差异，只对部分扩充语法进行了有针对性的转换。最终，所有文件被统一打包到 bundle.js 中。由此可见，运行时方法对语法几乎没有严格的限制，这有助于提高开发效率。然而，随着项目复杂度的增加，bundle.js 的加载和运行时大量的 DomData 更新可能会影响页面性能。 总结我们来回顾一下跨端解决方案： 应用场景：1）提供业务获取公域流量的手段；2）保障用户多渠道体验一致性；3）降低多渠道开发成本，提高迭代效率 技术方案&amp;实现：技术路线分两种：编译时、运行时 编译时方案：将JSX构建为符合各个容器所需的文件，并实现生命周期映射与数据映射。优点：性能好；缺点：迭代效率低 运行时方案：将页面组件统一打包到一个 bundle，通过虚拟 Dom 的方式进行页面视图渲染更新。优点：迭代效率高；缺点：性能相对较差","link":"/2024/03/19/mini-program/framework/"},{"title":"E2E 测试框架 cypress 实践","text":"什么是 Cypress？ Cypress 是非常年轻但很受开发者欢迎的测试框架，mac本地开发的话不需要安装别的依赖，npm install Cypress 即可，开箱即用，对于ES6 ES7的语法天然支持，不仅支持本地浏览器直接模拟测试，也支持终端测试。还有测试录屏功能，方便在测试失败的时候，查看当时的失败的场景，方便修改。整体来说上手快，学习成本较低。对于一下 Casperjs，感觉是全方面秒杀。 安装 Cypress环境依赖 Mac OS 10.9+ (Mavericks+), only 64bit binaries are provided for macOS. Linux Ubuntu 12.04+, Fedora 21, Debian 8, 64-bit binaries Windows 7+, only 32bit binaries are provided for Windows. 如果在Cli 中运行需要确保系统安装以下依赖apt-get install xvfb libgtk2.0-0 libnotify-dev libgconf-2-4 libnss3 libxss1 libasound2，使用docker的用户可以参考 cypress-docker-images 安装命令1234# macnpm install cypress -D# 安装完成后可以使用cypress verify 运行成功即为安装成功node_modules/.bin/cypress verify 使用 Cypress当安装完成cypress后，运行node_modules/.bin/cypress open， 会打开一个可视化界面，然后cypress会在你的工作目录下生成一个cypress目录1234567891011121314151617181920212223242526272829cypress├── fixtures│ └── example.json├── integration # 测试文件│ └── examples│ ├── actions.spec.js│ ├── aliasing.spec.js│ ├── assertions.spec.js│ ├── connectors.spec.js│ ├── cookies.spec.js│ ├── cypress_api.spec.js│ ├── files.spec.js│ ├── local_storage.spec.js│ ├── location.spec.js│ ├── misc.spec.js│ ├── navigation.spec.js│ ├── network_requests.spec.js│ ├── querying.spec.js│ ├── spies_stubs_clocks.spec.js│ ├── traversal.spec.js│ ├── utilities.spec.js│ ├── viewport.spec.js│ ├── waiting.spec.js│ └── window.spec.js├── plugins # 定义一些初始化设置跟变量│ └── index.js└── support # 可以抽取一些公共的方法作为我们的私有命令 ├── commands.js └── index.js 先写一个简单的测试测试一下百度的搜索功能 12345678// cypress/integration/baidu.spec.jsdescribe('首页检测', () =&gt; { it('应该能进入首页，并且能搜索', () =&gt; { cy.visit('https://baidu.com'); cy.get('#kw').type('cypress').wait(2000).get('#su').click().get('#kw').type(' github'); });}); 在 Cypress 的可视化界面里面，我们可以清晰的看到我们的测试代码每一步在做什么。除了可视化界面外，Cypress还支持在ci中运行（注意linux环境需要安装上诉依赖），只需要运行cypress run即可。并且在ci中的运行，cyprss会将操作记录在cypress/videos文件夹中，如果失败了也会记录下最后失败场景的截图。这样我们再自动化测试中，如果失败了也能轻松的追溯到案发现场！ 最后记录下我在使用 Cypress 些问题跟经验 在ci中运行一定要记得安装环境依赖，如果对于安装有疑问，可以翻阅cypress-docker-images 我们可以利用 commands 功能进行一些公用方法的封装。（示例见下） 可以在 cypress/plugins/index.js 设置一些基础的环境变量之类的数据，方便统一管理12345678910111213141516// cypress/plugins/index.jconst baseUrls = { dev: 'http://localhost:8080/', test: 'http://test.com prod: 'http://prod.com};module.exports = (on, config) =&gt; { // TODO: 根据不同的环境变量切换一些配置 const testENV = process.env.TEST_ENV || 'dev'; config.env['TEST_ENV'] = testENV; config.baseUrl = baseUrls[testENV]; return config;}; 对于 Cypress 获取 iframe 里面的元素，目前 Cypress 还没有像 testcafe 框架一样的 switchToIframe 方法，目前这个方法在 Cypress 的规划中，但是我们可以使用另外一种方式去获取。 123456789101112131415161718192021// 可以给 cypress comand cypress/support/commands.jsCypress.Commands.add('iframe', { prevSubject: 'element' }, $iframe =&gt; { return new Cypress.Promise(resolve =&gt; { resolve($iframe.contents().find('body')); });});// 在使用的时候只需要get到了之后，调用一下就可以切入到iframe里面 cypress/integration/**.spec.jscy.get('iframe').iframe()// 划重点 必须要配置一下浏览器打开时候的属性 cypress/plugins/index.jsmodule.exports = (on, config) =&gt; { on('before:browser:launch', (browser = {}, args) =&gt; { // 为了解决iframe 读取的问题 https://peter.sh/experiments/chromium-command-line-switches/ // issue： https://github.com/cypress-io/cypress/issues/136 if (browser.name === 'chrome') { args.push('--disable-site-isolation-trials'); return args; } });};","link":"/2018/12/06/test/cypress/"},{"title":"Symbol 实用指南","text":"点击查看原文 JavaScript 在 ES6 中引入了 Symbols 作为防止属性名称冲突的方法。并且 Symbols，还提供了一种在2015-2019 JavaScript中模拟私有属性的方法。 简介创建一个 symbol 非常的简单，只需要\b调用一下 Symbol() 函数就可以。\bsymbol 有两个比较特殊的特性 Symbols \b可以作为 Object 的 keys，\b并且有且只有 strings 和 symbols 才能作为 Object 的 keys。 两个 symbols 是不相等的 1234567891011const symbol1 = Symbol();const symbol2 = Symbol();symbol1 === symbol2; // falseconst obj = {};obj[symbol1] = 'Hello';obj[symbol2] = 'World';obj[symbol1]; // 'Hello'obj[symbol2]; // 'World' \b尽管使用 Symbol() \b创建 symbols 让 symbols 看起来就像是一个 object, 但是 symbols 是一个基础数据类型，如果使用 Symbol 实例化一个构建函数将会抛出异常 1234567const symbol1 = Symbol();typeof symbol1; // 'symbol'symbol1 instanceof Object; // false// Throws &quot;TypeError: Symbol is not a constructor&quot;new Symbol(); 说明Symbol() 接受一个字符串参数，这个字符串主要起到描述说明的作用，通常都是为了 debugging - 字符串会在调用 symbols 的 toString() 方法时展示。然而，即使两个symbol的描述字符串相等，那两个 symbols 也是不相等的。 12345const symbol1 = Symbol('my symbol');const symbol2 = Symbol('my symbol');symbol1 === symbol2; // falseconsole.log(symbol1); // 'Symbol(my symbol)' 有一种全局注册 symbol \b的方法，在创建 \bsymbol 的时候使用 Symbol.for(String) 创建，这个 symbol 会被注册到全局，并且按传入的字符串做区分。换句话说就是，如果你通过 Symbol.for(String) 创建了两个 symbol，并且传入的字符串是相等的，那么这两个 symbol 就是相等的。 12345const symbol1 = Symbol.for('test');const symbol2 = Symbol.for('test');symbol1 === symbol2; // trueconsole.log(symbol1); // 'Symbol(test)' 一般来说，除非有特殊情况才会使用这种方式去创建 symbol，否则不要使用，因为有可能会遇到命名冲突。 命名冲突Symbol.iterator 是第一个使用 symbol 的，具有 Symbol.iterator 函数作为 key 的对象被认为是可迭代的。这意味着该对象可以使用for / of循环。(关于Symbol.iterator 与循环可以查看，iterator 和 for…of 循环) 123456789101112131415161718192021222324const fibonacci = { [Symbol.iterator]: function*() { let a = 1; let b = 1; let temp; yield b; while (true) { temp = a; a = a + b; b = temp; yield b; } }};// Prints every Fibonacci number less than 100for (const x of fibonacci) { if (x &gt;= 100) { break; } console.log(x);} 为什么 Symbol.iterator 是一个 \bsymbol 而不是一个 string ?\b现在\b我们来\b做个假设，用字符串 iterator替换掉 Symbol.iterator 来检查一个对象是否可以被迭代。并且，\b你又下面这样一个类，可以被迭代 12345678910111213141516class MyClass { constructor(obj) { Object.assign(this, obj); } iterator() { const keys = Object.keys(this); let i = 0; return (function*() { if (i &gt;= keys.length) { return; } yield keys[i++]; })(); }} 实例化一个 MyClass 将会迭代对象上的所有的key，这就会有一个\b潜在的问题，假设\b故意传递了一个 iterator 属性 1const obj = new MyClass({ iterator: 'not a function' }); 如果这个时候你使用 for/of 去循环 obj，就会抛出一个异常 TypeError: obj is not iterable。因为用户自定义的 iterator \b会覆盖原本类的 iterator 属性（在调用 iterator 方法时，会优先找到用户自定义额那个，这样就会报错）。这是很典型的原型污染\b的问题，随便复制用户数据可能导致一些像__proto__\b和 constructor \b特殊属性出现问题。 这种模式很重要的一点就是 symbols 能够很好的\b分割一个对象中的用户数据跟\u001c程序数据。由于symbol无法用JSON表示，因此不存在将数据传递到具有错误 Symbol.iterator 属性的 Express API的风险。在将用户数据与内置函数和方法（如Mongoose的models）混合的对象中，可以使用符号来确保用户数据不会与内置功能冲突。 私有属性由于两个 symbols 是不相等的，所以使用 symbols 来定义一些\b私有属性是非常方便的。（话说\b我以前定义一些内部变量或者方法都会加上_fn，来表示私有）。Symbols 属性无法呗 Object,keys() 遍历出来，因此，除非是显式导出了一个 symbols，或者使用Object.getOwnPropertySymbols()函数，否则其他任何代码都无法访问该属性。 123456789101112131415161718function getObj() { const symbol = Symbol('test'); const obj = {}; obj[symbol] = 'test'; return obj;}const obj = getObj();Object.keys(obj); // []// Unless you explicitly have a reference to the symbol, you can't access the// symbol property.obj[Symbol('test')]; // undefined// You can still get a reference to the symbol using `getOwnPropertySymbols()`const [symbol] = Object.getOwnPropertySymbols(obj);obj[symbol]; // 'test' symbols 对于私有属性也很方便，因为它们不会显示在JSON.stringify()的输出中。准确来说，JSON.stringify() 以静默方式忽略符号键和值。 Symbols are also convenient for private properties because they do not show up in JSON.stringify() output. Specifically, JSON.stringify() silently ignores symbol keys and values. 1234const symbol = Symbol('test');const obj = { [symbol]: 'test', test: symbol };JSON.stringify(obj); // &quot;{}&quot; ###总结Symbols 是表示对象内部状态的绝佳工具，同时确保用户数据与程序状态保持独立。使用Symbols，不再需要使用’$’作为前缀程序状态属性的约定。因此，下次当您发现自己将对象属性设置为? __ internalFoo时，请考虑使用Symbols。","link":"/2019/08/19/translate/symbos/"},{"title":"react Hooks 实践总结","text":"最近在项目中实践了一下 react hooks，结合自己的经验，整理了一些文档，这里记录一下 常用的官方 hooks（官方文档）useState这个应该是我们最常用的 hook 了，用来代替 class 组件中的 setState基础用法：const [state, setState] = useState(initialState); 需要注意的点【查看代码】 setState 这里接受的参数除了一个给定的值外，还可以接受一个函数。例如 1234567891011const [count, setCont] = useState(0);setCount(count+1)setCount((prevCount) =&gt; prevCount + 1)// 上面用法通常使用在，我没法保证我获取的 count 是最新的值的情况下，比如在 useCallback 中const fn = useCallback(() =&gt; { console.log(count); // 这里的count 会一直是初始化的那个count，这个时候如果用 setCount(count + 1) 就会出现问题 setCount((prevCount) =&gt; prevCount + 1); // 这样就不会有问题}, []) // 这里最好传递要用到的依赖，否则会被缓存，获取不到最新的值 setState 会对值进行比较，如果 prevValue 跟这次的 value 相等的话（比较只是进行了浅比较），将不会触发更新。如果想强制每次更新，可以自定义一个hooks，例如 1234567// 如果是class 组件，每次调用setState 都会触发render，它不会对前后的值进行比较const useFocusUpdate = () =&gt; { const [ignore, update] = useState(0); return () =&gt; { update(ignore + 1); };}; initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。 useEffect基础用法: useEffect(fn, [deps]) 【后面的Fn， deps，均指的此处，Fn2指的是 Fn的返回函数】默认情况下useEffect 接受的函数 Fn 会在 render 之后执行，Fn 执行后，如果返回了一个函数Fn2，那么Fn2，在执行下一个 effect 之前，即上一个 effect 销毁时 12345678910111213141516171819202122export default function App() { console.log('start') const [count, setCount] = useState(0); useEffect(() =&gt; { console.log('log on effect', count); return () =&gt; { console.log('log on effecct return fn', count); } }, [count]) console.log('render') return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;{count}&lt;/h1&gt; &lt;h2 onClick={() =&gt; setCount(count + 1)}&gt;Add Count&lt;/h2&gt; &lt;/div&gt; );}// 打印顺序// start render log on effect 0// 点击 Add Count 触发 count 更新，打印顺序// start render log on effecct return fn 0 log on effect 1 需要注意的点 在Fn中使用到的变量需要传入的 deps，否则会出现取不到最新的值的问题 传入 deps 的值也需要注意，不要传递函数中的方法，例如 123456789101112// 这样会造成死循环，因为每一次重新 render handle 就会被重新创建，useEffect 每次都会检测到变化，每次就会执行function App() { const [count, setCount] = useState(0); const handle = () =&gt; { setCount(count + 1) }; useEffect(() =&gt; { handle(); }, [fn]) return ( &lt;div className=&quot;App&quot;&gt; &lt;/div&gt; );} useEffect 经常被用到的使用场景 模拟 DidMountuseEffect(fn, []) 传入一个空数组即可，fn 会在首次 render 后执行，之后再也不会执行，fn 返回的函数会在组件销毁时执行，即为 willUnmount 用来监变量变化，例如 123456789// 当 city 出现变化后，我们重新开始拉取 城市信息，城市下面的运营信息，城市下面的POI等信息useEffect(() =&gt; { if (cityId !== null) { fetchCityInfo(); fetchCategoryList(); fetchOperationResource(); fetchPoiList(); }}, [cityId]); useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。 为什么会有这个hook呢？因为前面说的，组件更新的时候，组件内的内联函数都会被重新创建，如果我们将这个内联函数变成依赖，或者传递给某个子组件，都会导致一些性能问题。 应用场景 123456789101112131415161718// 这种写法，如果 App 需要re-render，Children 也会出现 re-render，因为handle这个函数每次都被重新被创建了function App() { const handle = () =&gt; { ... } return ( &lt;div className=&quot;App&quot;&gt; &lt;Children onClick={handle}/&gt; &lt;/div&gt; );}function App() { const handle = useCallback(fn, [deps]); // fn 中如果用到了某个state，需要放在deps中，否则拿到的 state 不是最新的 return ( &lt;div className=&quot;App&quot;&gt; &lt;Children onClick={handle}/&gt; &lt;/div&gt; );} useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) 应用场景 需要复杂计算的时候，可以用来存储， 例如 12345678910function App() { // computeExpensiveValue 是一个非常复杂的计算函数，这样做了后，只要依赖的 a 不发生变化， // computeExpensiveValue是不会重复执行的，value是一个 memoized 值。 const value = useMemo(() =&gt; computeExpensiveValue(a), [a]); return ( &lt;div className=&quot;App&quot;&gt; {value} &lt;/div&gt; );} 用 useMemo 来优化引用数据的传递，例如 123456789101112131415161718// 这种写法，如果 App 需要re-render，Children 也会出现 re-render，因为 Children 的 style 这个值一直都被重新创建function App({ height }) { return ( &lt;div className=&quot;App&quot;&gt; &lt;Children style={{ height }}/&gt; &lt;/div&gt; );}// 用 useMemo 来记忆，减少 Children 的 re-renderfunction App({ height }) { const childrenStyle = useMemo(() =&gt; ({ height }), [height]) return ( &lt;div className=&quot;App&quot;&gt; &lt;Children style={childrenStyle}/&gt; &lt;/div&gt; );} useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 基本用法跟注意点【查看代码】 用来访问dom节点，或者访问一堆列表的节点 12345678910111213141516171819202122// 注意 需要首次渲染结束后，ref.current 上面才有对应的 dom。如果 dom 被移除了对应的 ref.currnt 就会变成 nullexport default function App() { const [show, setVisible] = useState(true); const ref = useRef(null); const listRef = useRef([]); useEffect(() =&gt; { console.log(listRef); }, [ref2]) return ( &lt;div className=&quot;App&quot;&gt; {show &amp;&amp; &lt;div ref={ref}&gt;dom1&lt;/div&gt;} {ary.map((num, index) =&gt; &lt;div key={num} ref={(_ref) =&gt; { listRef.current[index] = _ref; }}&gt;{num}&lt;/div&gt;)} &lt;div onClick={() =&gt; { console.log(ref.current); setVisible(!show) }}&gt;click me&lt;/div&gt; &lt;/div&gt; );} ref是不能被监听的 1234567891011121314export default function App() { const ref2 = useRef(0); useEffect(() =&gt; { // ref2 改变后 并不会重新触发此函数 console.log(ref2); }, [ref2]) return ( &lt;div className=&quot;App&quot;&gt; &lt;div onClick={() =&gt; { ref2.current = Math.random(); }}&gt; change ref&lt;/div&gt; &lt;/div&gt; );} 用来存储一些不用引起 re-render 但是需要变化的变量。例如 12345678910111213export default function App() { const hadSendMc = useRef(false); return ( &lt;div className=&quot;App&quot;&gt; &lt;div onClick={() =&gt; { if(hadSendMc.current){ return; } console.log('send mc') hadSendMc.current = true; }}&gt;send mc&lt;/div&gt; &lt;/div&gt; useImperativeHandleuseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用。我在项目中只用到了一次，主要是给父组件暴露自定义的方法，而不是一股脑的直接返回ref，房子父组件操作ref导致问题 使用示例 12345678910111213141516171819202122232425const Video = ({ ... }: PropTypes, ref: any) =&gt; { const videoRef: any = useRef(null); const playVideo = () =&gt; {...}; const handlePlayBtnClick = () =&gt; {...}; useImperativeHandle(ref, () =&gt; ({ play: playVideo, pause: () =&gt; { if (videoRef.current) { videoRef.current.pause(); setVideoVisible(false); } }, })); return ( &lt;div className={styles.container}&gt; &lt;video ref={videoRef}&gt; &lt;source src={videoUrl} type=&quot;video/mp4&quot; /&gt; &lt;/video&gt; &lt;/div&gt; );};export default React.memo(React.forwardRef(Video)); 后续如果使用了，我会同步补上useContext (这个我没有用过，略)useReducer (这个我没有用过，略)useLayoutEffect (这个我没有用过，略)useDebugValue (这个我没有用过，略) 常用的优化手段 使用 React.memo 去优化由于 Function Component 组件没有类似 shouldComponentUpdate 这样的方法，也没法继承 PureComponent，我们就可以使用 React.memo去做优化注意：React.memo仅影响 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。使用示例：React.memo(MyComponent, areEqual);默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。 利用 useCallback 跟 useMemo 去缓存数据，具体可以看上面的示例 如果使用了 react-redux，可以通过 useSelect 的第二个参数去做优化使用示例：const result : any = useSelector(selector : Function, areEqual? : Function) 项目中自定义的 hook 梳理 针对具体的业务具体开发，笔者这里只是抛砖迎玉 发送页面PV 12345678910export const usePageView = (pageId) =&gt; { const hadSendPv = useRef(false); useEffect(() =&gt; { if (hadSendPv.current) { return; } sendPv(); }, [pageId]);}; useIntersectionObserver 用来监听 dom 是否出现在可视窗口。注意需要引用 intersection-observer-polyfill 123456789101112131415161718192021222324252627282930313233343536373839export const useIntersectionObserver = (cb: ObserveCallback, ref?: any, startObserver = true) =&gt; { const io: any = useMemo(() =&gt; new IntersectionObserver((IntersectionObserverEntryList: any) =&gt; cb(IntersectionObserverEntryList, io)), [cb]); const observerRef: any = useRef(ref || null); useEffect(() =&gt; { if (!observerRef.current || !startObserver) { return; } if (observerRef.current instanceof Array) { const eleList = observerRef.current; eleList.forEach((ele: any) =&gt; { io.observe(ele); }); return () =&gt; { eleList.forEach((ele: any) =&gt; { io.unobserve(ele); }); }; } const ele = observerRef.current; io.observe(ele); return () =&gt; { io.unobserve(ele); }; }, [io, startObserver]); return observerRef;};// 使用方法function App({ height }) { const observerHandle = useCallback(() =&gt; { ... }, []); const observerRef = useIntersectionObserver(observerHandle) return ( &lt;div className=&quot;App&quot; ref={observerRef}&gt; &lt;Children style={{ height }}/&gt; &lt;/div&gt; );} 抽离微信分享设置 1234567const environment = { ... };export const useWechatShare = (shareInfo: any) =&gt; { if ((environment.isMini() || environment.isWx) &amp;&amp; shareInfo.shareUrl) { // 微信分享设置 } }, [shareInfo, environment]);}; useScroll 页面滚动函数绑定 注意：此处不是相对于body滚动的！123456789101112131415161718export const useScroll = (handle: ScrollHandle, threshHold: number = 250) =&gt; { const handleWrapper = useCallback(throttle(handle, threshHold), [handle]); const containerId = 'containerId'; useEffect(() =&gt; { let listerEle: any = window; if (containerId) { listerEle = document.getElementById(containerId); } console.log('useScroll 注入成功'); if (listerEle) { listerEle.addEventListener('scroll', handleWrapper); return () =&gt; { listerEle.removeEventListener('scroll', handleWrapper); }; } }, [handleWrapper, containerId]); } 总结 react hooks 的出现提供了我们更好的模块化代码的方式，我们从以前的抽离公共UI的方式，可以变为更小粒度的拆分，例如拆分某个公共的逻辑 react hooks 能够大大的减少我们大代码量，不需要再去理解复杂的class Component，一切都变的更加简单了 在使用的过程中一定要注意到，Function Component 始终是函数，只要re-render，里面的代码都会重新执行，内联函数，内联对象都会被重新创建","link":"/2020/01/22/react/hooks/"},{"title":"hooks 实现简易版 react-redux","text":"在我的日常开发过程中，经常会用到 react-redux 去做状态管理，现在的 react-redux 已经支持 hooks 了，今天我们就来实现一款简易版本的 react-redux 1. 我们需要实现什么 Provider 组件，用于存储 store，挂载带有 context 的组件 useDispatch 用来获取 dispatch useSelect 用来在组件中获取 store 中的数据 2. 确定我们的用法 最外层是我们的 Provider 组件，即 1234const store = createStore(reducer);&lt;Provider store={store}&gt; &lt;App/&gt;&lt;/Provider&gt; 在组件中获取 store中的数据展示，获取 dispach，改变store中的值，即 1234567891011const ChildA = () =&gt; {// selector 获取 store 中指定的数据。如：state =&gt; state.count// equalityFn 通过比较前后的 state 来判断此次是否需要 re-renderconst { count } = useSelct(selector, equalityFn);const disptach = useDispatch();return ( &lt;div&gt; &lt;p onClick={() =&gt; dispatch({ type: 'ADD_COUNT'})}&gt;child B:{count}&lt;/p&gt; &lt;/div&gt; );}; 3.实现 Provider 组件这个组件其实很简单，接受 store 作为props，然后将 store传给 Context.Provider 即可Context 官方文档 1234const StoreContext = React.createContext();const Provider = ({ store, children }) =&gt; { return &lt;StoreContext.Provider value={store}&gt;{children}&lt;/StoreContext.Provider&gt;;}; 4. 实现 useDispatch将 store 中的 dispatch 方法返回即可useContext 官方文档 12345const useDispatch = () =&gt; { const store = useContext(StoreContext); const dispatch = store.dispatch; return dispatch;}; 5. 实现 useSelect 我们先不管获取指定的state，跟比较前后state这两个功能，先就简单的实现以下，从 store 中获取state，那么实现就很简单 12345const useSelect = () =&gt; { const store = useContext(StoreContext); const state = store.getState(); return state;}; 我们加入 selector 方法，获取指定的 state，这时候，我们只需简单的改动以下代码即可 123456789const useSelect = (selector= data =&gt; data) =&gt; { const store = useContext(StoreContext); try { const state = selector(store.getState()); return state; } catch(e) { throw new Error(`useSelect.selector get data Error. Err: ${e} `) }}; 做完之后，我们发现，如果我的store里面的值怎么改变都不会重新触发 re-render， 应为对于组件而言，他并没有状态改动，store一直是没有变化的。那么我们只需监听以下store里面的值的变化，然后触发更新 12345678910111213141516const useSelect = (selector= data =&gt; data) =&gt; { const [, forceRender] = useReducer((s) =&gt; s + 1, 0); const store = useContext(StoreContext); useEffect(() =&gt; { const unsubscribe = store.subscribe(() =&gt; { forceRender(); }); return unsubscribe; }, [store]) try { const state = selector(store.getState()); return state; } catch(e) { throw new Error(`useSelect.selector get data Error. Err: ${e} `) }}; 这样的问题来了，即使我们组件引用的state没有发生改变，也会触发更新，这样对性能而言是可以优化的，最后我们引入我们的 equalityFn 12345678910111213141516171819202122232425262728293031323334const useSelect = (selector = (data) =&gt; data, equalityFn) =&gt; { const [, forceRender] = useReducer((s) =&gt; s + 1, 0); const store = useContext(StoreContext); let state; try { state = selector(store.getState()); } catch(e) { throw new Error(`useSelect.selector get data Error. Err: ${e} `) } const lastDataCache = useRef({ state, selector, equalityFn }); lastDataCache.current.selector = selector; lastDataCache.current.equalityFn = equalityFn; const checkForUpdate = useCallback(() =&gt; { try { const newState = lastDataCache.current.selector(store.getState()); const result = lastDataCache.current.equalityFn(lastDataCache.current.state, newState); // 需要更新 if (!result) { forceRender(); lastDataCache.current.state = newState; } } catch (e) { console.warn(`useSelect.useSelect Error. Err:${e}`) forceRender(); } }, [store]); useEffect(() =&gt; { const unsubscribe = store.subscribe(checkForUpdate); return unsubscribe; }, [store, checkForUpdate]); return state; 代码地址","link":"/2020/03/16/react/hooks-redux/"},{"title":"用hooks模拟 React 生命周期","text":"使用hooks有一段时间了，之前也针对自己的使用经验整理了一下。对比 class 组件的生命周期，利用 hooks 如何实现呢？ 首先说一下 react 的几个阶段 挂载 constructor static getDerivedStateFromProps UNSAFE_componentWillMount 后期会被废弃 render componentDidMount 更新 static getDerivedStateFromProps UNSAFE_componentWillReceiveProps 后期会被废弃 UNSAFE_componentWillUpdate 后期会被废弃 shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate 卸载 componentWillUnmount 挂载constructor 这个构造函数没法模拟 getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 12345678910111213141516171819202122232425// 这里注意到其实这个state并不是真实的state，而是一个跟props相关的对象const useGetDeriveStateFromProps = (state, props, handle) =&gt; { const cacheState = useRef(state); const newState = handle(cacheState.current, props); if (newState) { cacheState.current = newState; } return cacheState.current;};// 使用const Component = props =&gt; { const state = useGetDeriveStateFromProps({ x: 1 }, props, (state, props) =&gt; { console.log('new getDerivedStateFromProps') if (props.add) { state.x += 1; return state; } return null; }); return &lt;div&gt;{state.x}&lt;/div&gt;;}; UNSAFE_componentWillMount 在 render 之前执行，且执行一次 1234567const useWillMount = handle =&gt; { const isFirstLoad = useRef(true); if (isFirstLoad.current) { handle(); isFirstLoad.current = false; }}; componentDidMount 会在组件挂载后（插入 DOM 树中）立即调用，且整个生命周期中只会调用一次 123const useDidMount = handle =&gt; { useEffect(handle, []);}; 更新getDerivedStateFromProps 上面已经说过了 UNSAFE_componentWillReceiveProps 当 props 改变的时候触发，且在 render 之前 123456789101112const useWillReceiveProps = (props, handle) =&gt; { const cacheProps = useRef(props); const isFirst = useRef(true); if (isFirst.current) { isFirst.current = false; return; } if (cacheProps.current !== props) { handle(); cacheProps.current = props; }}; UNSAFE_componentWillUpdate 当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。每次render前都会调用 12345678const useWillUpdate = handle =&gt; { const isFirst = useRef(true); if (isFirst.current) { isFirst.current = false; return; } handle();}; shouldComponentUpdate 根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。 这里可以用 React.memo 去优化函数组件的，且useState是会进行浅比较state\\ getSnapshotBeforeUpdate 在最近一次渲染输出（提交到 DOM 节点）之前调用。 它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。 此生命周期的任何返回值将作为参数传递给 componentDidUpdate 这里有点难解决，可以考虑讲整个生命周期抽象出来 componentDidUpdate 会在更新后会被立即调用。首次渲染不会执行此方法。 123456789101112131415// 注意这里漏掉了 snapshot，也就是 getSnapshotBeforeUpdate 的返回值const useDidUpdate = (props, states, handle) =&gt; { const isFirst = useRef(true); const cacheHandle = useRef(handle); const cache = useRef({ props, states }); cacheHandle.current = handle; useEffect(() =&gt; { if (isFirst.current) { isFirst.current = false; return; } cacheHandle.current(cache.props, cache.state); cache.current = { props, states }; });}; 卸载componentWillUnmount 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。 12345const useWillUnmount = handle =&gt; { const _handle = useRef(); _handle.current = handle; useEffect(() =&gt; _handle.current, []);}; setState 模拟12345const useSetState = (state) =&gt; { const [data, setData] = useState(state); const setState = (newState) =&gt; setData((state) =&gt; ({ ...state, ...newState})) return [data, setState];}","link":"/2020/02/28/react/life/"},{"title":"React re-render 优化指南","text":"React 作为一个视图框架，一般情况下速度已经很快了，并且在 React16 新推出的 Fiber 架构中，通过时间切片及高优先级任务中断来尽快相应用户的操作。但是有些我们忽略点，造成了不必要的组件 re-render，从而造成性能的浪费。 如何阻止不必要的 re-render 使用 pureComponent当组件更新时，pureComponent 会在 shouldComponentUpdate 帮我们比较一下 props 跟 state, 如果组件的 props 和 state 都没发生改变，render 方法就不会触发。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) { shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);}return shouldUpdate; 而 shallowEqual 又做了什么呢？会去判断 prev 跟 next 的 key 是否一致，且对应的值跟引用是否相等。（注意这里是引用是否相等，两个即使内容相同的对象，也是不相等的） 虽然有了一层浅比较，但是更多的时候，由于我们的写法的问题，使得这层比较失效了。 123456789101112131415// Child extends PureComponentclass Parent extends Component { render() { return ( &lt;div&gt; &lt;Child style={{ width: 100 }} onClick={() =&gt; { // do something }} /&gt; &lt;/div&gt; ); }} 上面的这种写法，会导致每次 Child 必定重复更新，因为每次传递进来的 onClick 和 style 都是与上次不相等的。 将这些不变的数据使用同一个引用 1234567891011121314// Child extends PureComponentclass Parent extends Component { onChildClick = () =&gt; { // do something }; childStyle = { width: 100 }; render() { return ( &lt;div&gt; &lt;Child onClick={this.onChildClick} style={this.childStyle} /&gt; &lt;/div&gt; ); }} 使用 React.memoReact.memo 为高阶组件。它与 React.PureComponent 非常相似，但它适用于函数组件，但不适用于 class 组件。 如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。 默认情况下其只会对复杂对象做浅层对比(与 pure 类似)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。 12// 如果 areEqual 不传递的话使用默认的浅比较export default React.memo(MyComponent, areEqual); 再说说上面同一个引用的问题，假设现在有下面这样一个组件 123456789101112const Child = React.memo(MyComponent);const Parent = () =&gt; { onChildClick = { // do something }; return ( &lt;div&gt; &lt;Child onClick={onChildClick} /&gt; &lt;/div&gt; );}; 这里就会有上面说的问题，每一次re-render 的时候 传递给 Child 的 onClick 都是新生产的 function，所以导致浅比较失效。这里我们可以用 useCallback 去进行优化。(关于 useCallback 简单使用介绍请查看 React hooks useCallback 指北) 123456789101112const Child = React.memo(MyComponent);const Parent = () =&gt; { const onChildClick = useCallback(() =&gt; { // do something }, []); return ( &lt;div&gt; &lt;Child onClick={onChildClick} /&gt; &lt;/div&gt; );}; 使用 react-redux 时候，优化 re-render可以在传递 props 时就做对比优化，不用再 shouldComponentUpdate 阶段去做 使用了 connect，每次store更新，不管是否与自身有关，都会导致组件re-render。其实 react-redux 是支持我们去做优化的。 12345678910111213/*options{ context?: Object, pure?: boolean, areStatesEqual?: Function, areOwnPropsEqual?: Function, areStatePropsEqual?: Function, areMergedPropsEqual?: Function, forwardRef?: boolean,}*/function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?) 我们可以通过 areStatePropsEqual 函数去做对比优化。 如果使用了 hooks，怎么优化呢 1const result : any = useSelector(selector : Function, equalityFn? : Function) 通过 equalityFn 去做优化。 总结 类组件使用 PureComponent 去做优化，函数组件使用 React.memo 去做优化 将这些不变的数据使用同一个引用，减少匿名函数的使用 react-redux 提前关注我们store，对相关store做处理 参考React.memo 和 PureComponent 文档不要滥用 React.memo","link":"/2019/09/05/react/re-render/"},{"title":"react compiler 你的性能优化助手","text":"前言在本文中，我们将深入探索 React Compiler，这是一个旨在优化React应用性能的先进工具。通过阅读，您将获得全面的见解，包括： React Compiler的背景与应用场景：介绍其发展历程、核心功能以及在现代Web开发中的应用。 环境搭建与编译选择：详解如何为新旧项目配置环境，以及如何根据项目需求选择合适的编译策略。 渲染原理及其对项目的影响：分析React Compiler的工作机制，探讨其如何影响项目结构和性能。 React Compiler 是什么React Compiler 最初在 React Conf 2021 作为 “React Froget” 概念首次提出，并于 React Conf 2024 后正式开源。这是一个用 Rust 编写的 “自动记忆编译器”，能够解析和分析 React 代码，并自动缓存代码。开发者无需任何额外操作，便可获得高性能的组件代码。 React Compiler 的应用场景在介绍 react compiler 之前，先简单介绍一下 react 的常用优化手段。我们知道引起组件render 的原因主要有以下三种 props 发生变化 state 发生变化 context 发生变化 我们常说的减少不必要的 re-render，主要是为了解决 props 变更带来的不必要的渲染。例如直接传递匿名函数： 12345678910function App() { const [x, setX] = useState(0) return ( &lt;div&gt; &lt;div onClick={() =&gt; setX(Math.random())}&gt;哈哈哈哈{x}&lt;/div&gt; &lt;Link onCountClick={(count) =&gt; { console.log('====', count)}} /&gt; &lt;div&gt;hello，react compiler&lt;/div&gt; &lt;/div&gt; )} 当 APP 重新渲染，会重新执行 App 函数，在渲染 JSX时，会再次创建一个匿名函数传递给 Link 组件，尽管这个时候 Link 组件不需要重新渲染，但是由于 onCountClick 前后函数地址不一致，导致 Link 组件重新渲染。为了规避这种问题，我们可以使用 useCallback 对上述代码进行改造，同时使用 React.memo 对 Link 组件进行包裹。代码如下 1234567891011function App() { const [x, setX] = useState(0) const = onCountClick = useCallback((count) =&gt; { console.log('====', count }, []) return ( &lt;div&gt; &lt;div onClick={() =&gt; setX(Math.random())}&gt;哈哈哈哈{x}&lt;/div&gt; &lt;Link onCountClick={(count) =&gt; { console.log('====', count)}} /&gt; &lt;div&gt;hello，react compiler&lt;/div&gt; &lt;/div&gt; )} 通过 useCallback，只有当依赖变化时才会重新创建函数。这样，当 App 重新渲染时，如果 useCallback 的依赖未变，它会返回上次缓存的函数，避免了 Link 组件的不必要渲染。此外，API 如 useMemo 和 React.memo 也可以告诉 React，如果依赖未变，则无需重新计算缓存的内容，从而减少更新的工作量。 在实际开发中，虽然这些 API 可以帮助我们优化代码，但容易遗忘或错误地使用它们。如果组件未进行缓存优化，组件更新时的大量计算可能导致性能问题。错误的处理，虽然可以避免重复渲染，但可能严重影响代码质量，尤其是在依赖嵌套时： 12345678910111213141516const App = ({x, y, z}) =&gt; { const handleX = useCallback(() =&gt; { console.log(x); }, [x]) const handleY = useCallback(() =&gt; { handleX(); console.log(y) }, [y, handleX]); // 表面上只跟 z, handleY 有关，实际上，当 x 发生变化时，handleZ 也会出现变更，当代码量大的时候，很难直观的发现这一点 const handleZ = useCallback(() =&gt; { handleY(); console.log(z) }, [z, handleY])} 那有没有一种办法能够在保障代码可读性的同时，又能有效规避这些不必要的渲染与一些额外的处理呢？ React Compiler 提供了这样的解决方案。通过对 JavaScript 和 React 规则的深入了解，它对组件渲染节点进行分析，并自动对组件和钩子中的值或值组进行记忆化，从而细粒度控制组件渲染。 实操接下来，我们将通过一个实例来介绍如何搭建 React Compiler 环境，逐步揭开它的神秘面纱。建议大家在本地配置环境，并亲自查看编译后的源码。相关代码已上传至 github，可下载体验。 新项目搭建新项目会以 vite 的 react 模板进行演示，更多项目模板及配置请参考：react compiler 使用 1. react 模板下载1pnpm create vite my-react-app --template react-ts 2. 编译器配置编译配置，为了方便查看编译后的代码，这里暂时将hmr 与 sourcemap 关闭了，切勿在真实项目中这么处理！ 12345678910111213import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'// https://vitejs.dev/config/export default defineConfig({ plugins: [react({ babel: { plugins: [&quot;babel-plugin-react-compiler&quot;] }})], server: { hmr: false }, esbuild: { sourcemap: false, }}) eslint 插件下载： 1pnpm install eslint-plugin-react-compiler 规则配置 12345678module.exports = {... plugins: ['eslint-plugin-react-compiler'], rules: { 'react-compiler/react-compiler': &quot;error&quot;, },...} 尽管 react-compiler 在检测到错误时，会跳过编译不做处理，但为了更好的前置发现问题语法限制，最好开启 StrictMode 与 eslint 插件。 存量项目使用注意：由于 react compiler 会修改最后的输出产物，且目前发布的版本并非稳定版本，如需使用，建议采用局部编译的方式。 1. 使用 react-compiler-healthcheck 对老代码进行检查1npx react-compiler-healthcheck@latest 这个脚本对你的项目会做一下检查 检查可以成功优化多少组件：越多越好 检查 &lt;StrictMode&gt; 的使用情况：启用并遵循这一规则意味着优化成功率会更高。 检查不兼容的库使用：已知与编译器不兼容的库 以下是拿ANT DESIGN PRO检测后的结果： 2. 安装并配置上述的 eslint 插件 eslint-plugin-react-compiler如果当 eslint 检测到这些错误，compiler 默认会跳过这些文件的编译，不阻塞编译。 3. 安装 compiler 插件。安装方式与上述一致，需要注意的是虽然 compiler 会在识别到有语法不支持时跳过，但是由于 JavaScript 的灵活性，无法保障捕获到所有的异常。所以对于存量项目比较推荐使用局部编译的方式，局部编译的方式有三种 在编译插件指定对应的编译文件内容，例如 123456789101112import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'const ReactCompilerConfig = { sources: (filename: string) =&gt; { return filename.indexOf('src/components') !== -1; },};export default defineConfig({ plugins: [react({ babel: { plugins: [&quot;babel-plugin-react-compiler&quot;, ReactCompilerConfig] }})],}) 在源码侧使用按需编译 12345678910const ReactCompilerConfig = { compilationMode: &quot;annotation&quot;,};// src/app.jsxexport default function App() { &quot;use memo&quot;; // ...} 在源码侧指定组件不编译 在默认情况下，react-compiler 会进行全量编译，使用use no memo，可以告诉编译器，不要编译这个组件，但是需要注意的是：这只是一个临时方案，并不会长期使用 12345// src/app.jsxexport default function App() { &quot;use memo&quot;; // ...} 配置完成后，使用 react-dev-tool 插件组件编译情况。React compiler 会给优化后的组件加上标记，效果如下： 工作原理React Compiler并不仅仅是简单地对属性和变量添加useMemo和useCallback等API，而是通过依赖识别和数据缓存进行优化。与传统的React性能优化手段相比，它实现了更小的粒度和更好的效果，能够精确地实现最小化更新。 接下来我们看一段代码，有这样一个组件，它会获取当前链接的ID，然后根据 ID 去匹配到当前所需的要连接信息，然后将对应的信息传递给Link组件，Link 组件会拿到链接信息进行渲染，并且在点击链接时，会触发父组件传递的onLinkClick 回调，大致代码如下： 1234567891011121314151617181920212223242526import { useState } from 'react';import Link from './components/Link';import './App.css'const linkList = [{ id: 1, linkInfo: { text: '这是链接1', address: 'https://www.baidu.com/1' }}, { id: 2, linkInfo: { text: '这是链接2', address: 'https://www.baidu.com/2' }}];function App() { console.log('APP render'); const [linkId, setLinkId] = useState(1); const [random, setRandom] = useState(Math.random()); const linkInfo = linkList.find((item) =&gt; item.id === linkId)?.linkInfo; return ( &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;text1&quot; onClick={() =&gt; { setLinkId(linkId === 1 ? 2 : 1) }}&gt;当前 linkId 为：{linkId}&lt;/div&gt; &lt;Link linkInfo={linkInfo} onLinkClick={(link: string) =&gt; { console.log('====', link)}} /&gt; &lt;div id=&quot;text2&quot; onClick={() =&gt; { setRandom(Math.random()) }}&gt;这是一个随机数：{random}&lt;/div&gt; &lt;div id=&quot;text3&quot;&gt;这是一段关于 link Id 的介绍&lt;/div&gt; &lt;/div&gt; )}export default App 在不使用任何优化手段前，我们对比一下页面的re-render情况 优化前 优化后 在没有任何优化手段的情况下，每当组件状态变化时，整个组件树都会重新渲染。通过 react-compiler 处理后的组件，在随机数引起App 组件重现渲染时，Link组件并没有渲染，效果类似于使用useCallback 包裹onLinkChange匿名函数，同时对使用 React.memo对 Link组件进行包装。 那 React-compiler实际的处理是这样吗？，在此之前，先暂停两分钟，大家思考一下，在更细粒度的渲染过程中，APP组件中的 div 与Link组件，它们的渲染与什么有关？ 从子节点的渲染依赖分析： id 为 text1 的div，当 linkId 与 匿名函数发生变化时，需要重新渲染，**但是随机数发生变化时不需要** Link 组件，当linkInfo 与传递的匿名函数发生变化时需要重新渲染，**但是随机数发生变化时不需要** id 为 text2 的 div，当随机数发生变化时需要重新渲染，**但是 linkId 发生变化时，不需要** id 为 text3 的 div，它只需要初始化渲染一次即可。 接下来，看一下 react compiler 处理后的源码（注：可关闭sourcemap 与hmr 源码更简洁）： react-compiler 根据代码静态识别生产了一个能够缓存20项内容的数组 $，以及 10 个跟 jsx 相关的 template。对源码的分析可得，react-compiler 将组件内部的渲染进行了更细粒度的拆分，每个子节点，均只跟自身渲染相关的元素有关，不再与组件本身绑定，如div#text3只会渲染一次，后续的渲染都会从$ 数组中读取缓存，这也与我们上述细粒度分析一致，整体可以看出来，编译后的代码相对更复杂，但执行效率会更高。 同时从源码来看，编译后的代码量是有一定程度提升的，那么整体的体积与编译耗时大概有多大变化呢？通过复杂项目组件 mock，来提升代码复杂度，简单对比了一下前后变化（项目代码并不大，数据仅供参考）： 使用 react-compiler 不使用 react-compiler 从构建体积和时间的角度来看，使用React Compiler虽然略有增加，但与其带来的性能提升相比，这种增加显得微不足道。 总结React Compiler的核心价值在于它提供了一种机制，通过细粒度的控制减少不必要的重新渲染，从而解决了由props、state 或 context 变更引起的性能问题。这一点在传统的React开发中是通过useCallback和React.memo等API手动实现的，而React Compiler自动化了这一过程。 实际应用中，React Compiler不仅帮助开发者避免了常见的性能陷阱，如错误地使用优化API导致的重复渲染，还提供了一个更为直观和可管理的方式来处理大规模应用中的复杂依赖关系。通过自动化分析组件渲染节点和值的依赖，React Compiler确保只有必要的组件在数据变化时才会更新。 但需要注意的是React Compiler 虽好，但其稳定性尚未得到全面认证，且官方建议 React 的版本在 React 19 RC以上，在实际的项目中，建议先采用局部优化的方式进行接入。","link":"/2024/06/18/react/react-compiler/"},{"title":"一次Toast组件引发的思考","text":"背景最近组内有一个新项目，需要用的Toast这样一个组件。心里想，这样的组件，还不是分分钟就搞定呀。然后一头砸进去了开始写。 如何做toast 的展示与否，跟展示什么我都交给父组件去做，Toast本身只管展示就可以了，内部需要任何别的逻辑第一版代码如下 12345678910111213import React from 'react';import styles from './style.module.css';const Toast = ({ content, showToast }) =&gt; { if (!showToast) { return null; } return &lt;div className={styles.container}&gt;{content}&lt;/div&gt;;};export default Toast; 然后再调用的地方，发现如果我需要使用Toast，那么我使用的地方都得引入一下，这显然很不友好。然后我就将控制Toast的展示与否交由最外层的App组件去做, 如果那里需要使用Toast，那么就将handleShowToast 传递下去就好了代码如下 123456789101112131415161718192021222324252627import React, { useState } from 'react';import Toast from '@components/Toast';const App = (props) =&gt; { const [showToast, setToastVisible] = useState(false); const [content, setToastContent] = useState(''); const handleShowToast = (toastContent, delay) =&gt; { setToastVisible(true); setToastContent(toastContent); const timer = setTimeOut(() =&gt; { setToastVisible(false); setToastContent(''); }, delay) } return ( &lt;div&gt; &lt;Toast showToast={showToast} content={content}/&gt; &lt;div&gt; ... &lt;/div&gt; &lt;/div&gt; );};export default App; 但是这样用起来还是不舒服，如果页面多了，那岂不是每一处页面都需要这么处理，如果层级比较深，那岂不是要一层一层的传递下去？ 综上所碰到的问题，我思考了一下我想要的Toast组件的样子 只需页面引入一次即可 Toast 本身的逻辑自己处理，不需要调用方去管 Toast 需要暴露一些 API，让业务方去调用 整理完上面的问题，想起了观察者模式的应用，我是不是可以，在 Toast 本身去订阅几个事件，然后当我想要处理跟Toast 相关逻辑的时候我再 emit 相关事件，事情是不是就变的简单了呢？ 首先我需要一个事件系统，这个事件系统需要满足以下功能 on 方法去订阅事件 off 去解除订阅 emit 方法去触发事件 有一个 list 去存储所有相关事件。最终实现的 event 如下 123456789101112131415161718192021222324252627interface EventD { list: any;}export default class Event implements EventD { list = new Map(); on(event: string, callback: any) { if (!this.list.has(event)) { this.list.set(event, []); } this.list.get(event).push(callback); return this; } off(event: string) { this.list.delete(event); return this; } emit(event: string, ...args: any) { if (this.list.has(event)) { this.list.get(event).forEach((callback: any) =&gt; setTimeout(() =&gt; callback(...args), 0)); } }} 有了事件系统，我们再去改造以下我们的Toast 1234567891011121314151617181920212223242526272829303132333435import React, { useEffect, useState } from 'react';import Event from '@lib/event';import styles from './style.module.css';const event = new Event();const Toast = () =&gt; { const [showToast, setToastVisible] = useState(false); const [content, setToastContent] = useState(''); useEffect(() =&gt; { event.on('showToast', (toastContent: string, delay: number = 2000) =&gt; { setToastContent(toastContent); setToastVisible(true); const timer = setTimeout(() =&gt; { clearTimeout(timer); setToastVisible(false); }, delay); }); return () =&gt; { event.off('showToast'); }; }); if (!showToast) { return null; } return &lt;div className={styles.container}&gt;{content}&lt;/div&gt;;};export default Toast;export const showToast = (content: string, delay?: number) =&gt; event.emit('showToast', content, delay); 这样我们就可以在APP组件内引用一次即可，如果需要展示 toast 的时候，只需要调用一下 Toast 组件暴露的 showToast 方法即可。 总结 类似 Toast 这样需要事件系统的组件还有很多，我们都可以往这样的思维方式上面去改造 在写 React 的时候不要总局限于，父子间的一层一层的传递","link":"/2019/12/07/react/toast/"},{"title":"React hooks useCallback 指北","text":"react useCallback 指北基本使用useCallback(callback: T, deps: DependencyList): callback 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 问题useCallback 返回的函数里面缓存了什么数据 1234567891011121314151617181920212223242526272829import React, { useCallback, useState } from 'react';class Child extends React.Component { shouldComponentUpdate(nextProps) { return nextProps.flag !== this.props.flag; } render() { console.log('Child render'); return &lt;div&gt;Child Count: {this.props.count}&lt;/div&gt;; }}const UseCallBack = () =&gt; { const [count, setCount] = useState(0); const [selfCount, setSelfCount] = useState(100); const memoizedCallback = useCallback(() =&gt; { console.log('count change', count, selfCount); }, [count]); return ( &lt;div&gt; &lt;Child count={count} flag={memoizedCallback} /&gt; &lt;p&gt;self Count：{selfCount}&lt;/p&gt; &lt;p onClick={() =&gt; setCount(count + 1)}&gt;child count add&lt;/p&gt; &lt;p onClick={() =&gt; setSelfCount(selfCount + 1)}&gt;self count add&lt;/p&gt; &lt;p onClick={() =&gt; memoizedCallback()}&gt;callback click&lt;/p&gt; &lt;/div&gt; 可以看到，当我们改变 selfCount 的时候，由于我们的deps里面只监听了 count，所以返回的 memoizedCallback 是没有变化的，Child 没有 re-render，当memoizedCallback执行的时候打印的selfCount 还是之前的状态，没有发生变化。 结论useCallback执行返回的函数，是第一个传入的第一个函数的 memoized 版本，并且会缓存 useState 的所有值，只有在 deps 发生变化，返回值才函数才会更新，其内部的 useState的 值才会更新。 使用场景123456789101112function Counter() { const [count, setCount] = useState(0); const handleIncr = () =&gt; { setCount(c + 1); }; return ( &lt;div&gt; {count} &lt;Child onClick={handleIncr} /&gt; &lt;/div&gt; );} 假设Child是一个非常复杂的组件，每一次点击它，我们会递增count，从而触发组将重新渲染。因为Counter每次渲染都会重新生成handleIncr，所以也会导致Child重新渲染，不管Child使用了PureComponent还是使用React.memo包装。 在这里我使用useCallback去缓存我们的 handleIncr。 123456789101112function Counter() { const [count, setCount] = useState(0); const handleIncr = useCallback(() =&gt; { setCount(count + 1); }, [count]); return ( &lt;div&gt; {count} &lt;Child onClick={handleIncr} /&gt; &lt;/div&gt; );} 只有在count发生变化的时候才会重新生成 handleIncr，这样虽然能避免了一些性能问题，但是如果需要监听的变量过多，比如 useCallback(fn, [a, b,c, d]) 这样就会让代码变的很乱。其实在这里我们只要改变一下思路，在setCount 这样操作的时候，不用闭包中的变量，而是使用函数，获取最新的值。 1234567891011121314151617const Child = React.memo(({ onClick }) =&gt; { console.log('child render'); return &lt;div onClick={onClick}&gt;click&lt;/div&gt;;});function Counter() { const [count, setCount] = useState(0); const handleIncr = useCallback(() =&gt; { setCount(c =&gt; c + 1); }, []); return ( &lt;div&gt; {count} &lt;Child onClick={handleIncr} /&gt; &lt;/div&gt; );} 这样 handleIncr 在每次 Counter re-render 的时候都不会改变，并且每次操作的也是最新值","link":"/2019/08/19/react/useCallback/"}],"tags":[],"categories":[{"name":"技术周刊","slug":"技术周刊","link":"/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"},{"name":"H5 开发","slug":"H5-开发","link":"/categories/H5-%E5%BC%80%E5%8F%91/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"端到端测试","slug":"端到端测试","link":"/categories/%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95/"},{"name":"翻译","slug":"翻译","link":"/categories/%E7%BF%BB%E8%AF%91/"},{"name":"react","slug":"react","link":"/categories/react/"}],"pages":[]}